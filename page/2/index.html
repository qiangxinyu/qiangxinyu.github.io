<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="一艘小船">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="一艘小船">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="qxy">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>一艘小船</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">一艘小船</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">说翻就翻</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/01/21/AndroidAddBaiduMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qxy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一艘小船">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/01/21/AndroidAddBaiduMap/" class="post-title-link" itemprop="url">Android 添加百度地图的问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-01-21 12:03:00" itemprop="dateCreated datePublished" datetime="2017-01-21T12:03:00+08:00">2017-01-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>好久没写东西了，一直在忙着学 <code>React native</code>。</p>
<p>今天给 <code>Android</code> 导入<code>百度地图</code> 的时候遇见定位监听不回调的问题，记录一下。</p>
<p>电脑系统：Mac OS 10.12.4</p>
<p>IDE： Android Studio 2.1.2</p>
<p>JRE: 1.8.0_121-b13 x86_64</p>
<p>手机：Mi-4c   </p>
<p>Android Version:  5.1.1LMY47V</p>
<h4 id="1-确定-百度key-设置正确"><a href="#1-确定-百度key-设置正确" class="headerlink" title="1.确定 百度key 设置正确"></a>1.确定 <code>百度key</code> 设置正确</h4><p><code>meta-data </code> 要放在 <code>application</code> 里面。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;application&gt;  </span><br><span class="line">    &lt;meta-data  </span><br><span class="line">        android:name=&quot;com.baidu.lbsapi.API_KEY&quot;  </span><br><span class="line">        android:value=&quot;开发者 key&quot; /&gt;  </span><br><span class="line">&lt;/application&gt;</span><br></pre></td></tr></table></figure>


<h4 id="2-确定权限都添加"><a href="#2-确定权限都添加" class="headerlink" title="2.确定权限都添加"></a>2.确定权限都添加</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;/&gt;</span><br><span class="line">&lt;!-- 这个权限用于进行网络定位--&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot;&gt;&lt;/uses-permission&gt;</span><br><span class="line">&lt;!-- 这个权限用于访问GPS定位--&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot;&gt;&lt;/uses-permission&gt;</span><br><span class="line">&lt;!-- 用于访问wifi网络信息，wifi信息会用于进行网络定位--&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot;&gt;&lt;/uses-permission&gt;</span><br><span class="line">&lt;!-- 获取运营商信息，用于支持提供运营商信息相关的接口--&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;&gt;&lt;/uses-permission&gt;</span><br><span class="line">&lt;!-- 这个权限用于获取wifi的获取权限，wifi信息会用来进行网络定位--&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot;&gt;&lt;/uses-permission&gt;</span><br><span class="line">&lt;!-- 用于读取手机当前的状态--&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;&gt;&lt;/uses-permission&gt;</span><br><span class="line">&lt;!-- 写入扩展存储，向扩展卡写入数据，用于写入离线定位数据--&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&gt;&lt;/uses-permission&gt;</span><br><span class="line">&lt;!-- 访问网络，网络定位需要上网--&gt;</span><br><span class="line">&lt;!-- SD卡读取权限，用户写入离线定位数据--&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;&gt;&lt;/uses-permission&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="3-需要设置-service"><a href="#3-需要设置-service" class="headerlink" title="3. 需要设置 service"></a>3. 需要设置 <code>service</code></h4><p> 也放在 <code>application</code> 里面，后面的版本号与导入的 <code>百度SDK</code> 版本号一致。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;service android:name=&quot;com.baidu.location.f&quot; android:enabled=&quot;true&quot; android:process=&quot;:remote&quot;&gt;</span><br><span class="line">	  &lt;intent-filter&gt;</span><br><span class="line">	       &lt;action android:name=&quot;com.baidu.location.service_v4.3&quot; &gt;</span><br><span class="line">	        &lt;/action&gt;</span><br><span class="line">	  &lt;/intent-filter&gt;</span><br><span class="line">&lt;/service&gt;</span><br><span class="line">	       </span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="http://lbsyun.baidu.com/index.php?title=androidsdk">百度官方文档</a></p>
<p><a target="_blank" rel="noopener" href="http://bbs.lbsyun.baidu.com/forum.php?mod=viewthread&tid=10847">http://bbs.lbsyun.baidu.com/forum.php?mod=viewthread&tid=10847</a></p>
<p><a target="_blank" rel="noopener" href="http://bbs.csdn.net/topics/390803526">http://bbs.csdn.net/topics/390803526</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/01/21/UMWXNotCallBack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qxy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一艘小船">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/01/21/UMWXNotCallBack/" class="post-title-link" itemprop="url">友盟微信支付不回调</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-01-21 12:03:00" itemprop="dateCreated datePublished" datetime="2017-01-21T12:03:00+08:00">2017-01-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这是友盟 <code>UMSocialSnsService.h</code> 里的一个处理回调的方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> Deprecated API</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 处理app的URL方法</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @param url 传入的url</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @return wxApiDelegate 实现微信代理对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+(<span class="type">BOOL</span>)handleOpenURL:(<span class="built_in">NSURL</span> *)url wxApiDelegate:(<span class="type">id</span>&lt;WXApiDelegate&gt;)wxApiDelegate;</span><br></pre></td></tr></table></figure>

<p>使用发现这个 <code>wxApiDelegate</code> 即使设置了也不会执行 <code>&lt;WXApiDelegate&gt;</code> 里的方法。</p>
<p>所以在微信支付的时候需要进行判断，使用微信SDK的方法设置代理。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  AppDelegate 中 支付回调信息处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="type">BOOL</span>)payCommleteWithOpenURL:(<span class="built_in">NSURL</span> *)url</span><br><span class="line">&#123;</span><br><span class="line">    GPPayTool * payTool = [GPPayTool shareGPPayTool];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([url.host isEqualToString:<span class="string">@&quot;uppayresult&quot;</span>]) &#123;</span><br><span class="line">        [payTool unionPayOpenURL:url];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([url.host isEqualToString:<span class="string">@&quot;safepay&quot;</span>]) &#123;</span><br><span class="line">        [payTool aliPayOpenURL:url];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([url.host isEqualToString:<span class="string">@&quot;pay&quot;</span>]) &#123;</span><br><span class="line">       <span class="keyword">return</span> [WXApi handleOpenURL:url delegate:payTool];</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> [UMSocialSnsService handleOpenURL:url];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我直接判断 <code>host</code> 是否为 <code>pay</code>，可能会跟别的第三方回调重复，保险起见你应该打印一下 这个 <code>url</code> ，可以看到微信支付的 <code>url</code> 格式为 <code>wx000000000://pay/?code=031i50Wd2tYa3R0cL9Ud2bGYVd2i50WE&amp;state=</code>， <code>wx000000000</code> 这里是你的微信的 <code>AppId</code>，你应该判断是否等于 &#96;&#96;wx000000000:&#x2F;&#x2F;pay&#96;: </p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[url.absoluteString isEqualToString:<span class="string">@&quot;wx000000000://pay]&quot;</span></span><br></pre></td></tr></table></figure>

<p>别学我。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/01/21/swiftExploreAndOptimization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qxy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一艘小船">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/01/21/swiftExploreAndOptimization/" class="post-title-link" itemprop="url">Swift 性能探索和优化分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-01-21 12:03:00" itemprop="dateCreated datePublished" datetime="2017-01-21T12:03:00+08:00">2017-01-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://onevcat.com/2016/02/swift-performance/">原文地址</a></p>
<p>Apple 在推出 Swift 时就将其冠以先进，安全和高效的新一代编程语言之名。前两点在 Swift 的语法和语言特性中已经表现得淋漓尽致：像是尾随闭包，枚举关联值，可选值和强制的类型安全等都是 Swift 显而易见的优点。但是对于高效一点，就没有那么明显了。在 2014 年 WWDC 大会上 Apple 宣称 Swift 具有超越 Objective-C 的性能，甚至某些情况下可以媲美和超过 C。但是在 Swift 正式发布后，很多开发者发现似乎 Swift 性能并没有像宣传的那样优秀。甚至在 Swift 经过了一年半的演进的今天，稍有不慎就容易掉进语言性能的陷阱中。本文将分析一些使用 Swift 进行 iOS&#x2F;OS X 开发时性能上的考量和做法，同时，笔者结合自己这一年多来使用 Swift 进行开发的经验，也给出了一些对应办法。</p>
<h2 id="为什么-Swift-的性能值得期待"><a href="#为什么-Swift-的性能值得期待" class="headerlink" title="为什么 Swift 的性能值得期待"></a>为什么 Swift 的性能值得期待</h2><p>Swift 具有一门高效语言所需要具备的绝大部分特点。与 Ruby 或者 Python 这样的解释型语言不需要再做什么对比了，相较于其前辈的 Objective-C，Swift 在编译期间就完成了方法的绑定，因此方法调用上不再是类似于 Smalltalk 的消息发送，而是直接获取方法地址并进行调用。虽然 Objective-C 对运行时查找方法的过程进行了缓存和大量的优化，但是不可否认 Swift 的调用方式会更加迅速和高效。</p>
<p>另外，与 Objective-C 不同，Swift 是一门强类型的语言，这意味 Swift 的运行时和代码编译期间的类型是一致的，这样编译器可以得到足够的信息来在生成中间码和机器码时进行优化。虽然都使用 LLVM 工具链进行编译，但是 Swift 的编译过程相比于 Objective-C 要多一个环节 – 生成 Swift 中间代码 (Swift Intermediate Language，SIL)。SIL 中包含有很多根据类型假定的转换，这为之后进一步在更低层级优化提供了良好的基础，分析 SIL 也是我们探索 Swift 性能的有效方法。</p>
<p>最后，Swift 具有良好的内存使用的策略和结构。Swift 标准库中绝大部分类型都是 struct，对值类型的使用范围之广，在近期的编程语言中可谓首屈一指。原本值类型不可变性的特点，往往导致对于值的使用和修改意味着创建新的对象，但是 Swift 巧妙地规避了不必要的值类型复制，而仅只在必要时进行内存分配。这使得 Swift 在享受不可变性带来的便利以及避免不必要的共享状态的同时，还能够保持性能上的优秀。</p>
<h2 id="对性能进行测试"><a href="#对性能进行测试" class="headerlink" title="对性能进行测试"></a>对性能进行测试</h2><p>《计算机程序设计艺术》和 TeX 的作者高德纳曾经在论文中说过：</p>
<blockquote>
<p>过早的优化是万恶之源。</p>
</blockquote>
<p>和很多人理解的不同，这并不是说我们不应该在项目的早期就开始进行优化，而是指我们需要弄清代码中性能真正的问题和希望达到的目标后再开始进行优化。因此，我们需要知道性能问题到底出在哪儿。对程序性能的测试一定是优化的第一步。</p>
<p>在 Cocoa 开发中，对于性能的测试有几种常见的方式。其中最简单是直接通过输出 log 来监测某一段程序运行所消耗的时间。在 Cocoa 中我们可以使用 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/CoreAnimation_functions/index.html#//apple_ref/c/func/CACurrentMediaTime">CACurrentMediaTime</a> 来获取精确的时间。这个方法将会调用 mach 底层的 mach_absolute_time()，它的返回是一个基于 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/mac/qa/qa1398/_index.html">Mach absolute time unit</a> 的数字，我们通过在方法调用前后分别获取两次时刻，并计算它们的间隔，就可以了解方法的执行时间：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> start <span class="operator">=</span> <span class="type">CACurrentMediaTime</span>()</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">let</span> end <span class="operator">=</span> <span class="type">CACurrentMediaTime</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;测量时间：<span class="subst">\(end <span class="operator">-</span> start)</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>为了方便使用，我们还可以将这段代码封装到一个方法中，这样我们就能在项目中需要测试性能的地方方便地使用它了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">measure</span>(<span class="params">f</span>: ()-&gt;()) &#123;</span><br><span class="line">    <span class="keyword">let</span> start <span class="operator">=</span> <span class="type">CACurrentMediaTime</span>()</span><br><span class="line">    f()</span><br><span class="line">    <span class="keyword">let</span> end <span class="operator">=</span> <span class="type">CACurrentMediaTime</span>()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;测量时间：<span class="subst">\(end <span class="operator">-</span> start)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">measure &#123;</span><br><span class="line">    doSomeHeavyWork()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CACurrentMediaTime</code> 和 log 的方法适合于我们对既有代码进行探索，另一种有效的方法是使用 Instruments 的 Time Profiler 来在更高层面寻找代码的性能弱点。将程序挂载到 Time Profiler 后，每一个方法调用的耗时都将被记录。</p>
<p>当我们寻找到需要进行优化的代码路径后，为其建立一个单元测试来持续地检测代码的性能是很好的做法。在 Xcode 中默认的测试框架 XCTest 提供了检测并汇报性能的方法：<code>measureBlock</code>。通过将测试的代码块放到 <code>measureBlock</code> 中，Xcode 在测试时就会多次运行这段代码，并统计平均耗时。更方便的是，你可以设定一个基准，Xcode 会记录每次的耗时并在性能没有达到预期时进行提醒。这保证了随着项目开发，关键的代码路径不会发生性能上的退化。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">testPerformance</span>() &#123;</span><br><span class="line">    measureBlock() &#123;</span><br><span class="line">        <span class="comment">// 需要性能测试的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/swiftExploreAndOptimization/test-measure.png" alt="measure"></p>
<h2 id="优化手段，常见误用及对策"><a href="#优化手段，常见误用及对策" class="headerlink" title="优化手段，常见误用及对策"></a>优化手段，常见误用及对策</h2><h3 id="多线程、算法及数据结构优化"><a href="#多线程、算法及数据结构优化" class="headerlink" title="多线程、算法及数据结构优化"></a>多线程、算法及数据结构优化</h3><p>在确定了需要进行性能改善的代码后，一个最根本的优化方式是在程序设计层面进行改良。在移动客户端，对于影响了 UI 流畅度的代码，我们可以将其放到后台线程进行运行。Grand Central Dispatch (GCD) 或者 <code>NSOperation</code> 可以让我们方便地在不同线程中切换，而不太需要去担心线程调度的问题。一个使用 GCD 将繁重工作放到后台线程，然后在完成后回到主线程操作 UI 的典型例子是这样的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue <span class="operator">=</span> dispatch_get_global_queue(<span class="type">QOS_CLASS_DEFAULT</span>, <span class="number">0</span>)</span><br><span class="line">    dispatch_async(queue) &#123;</span><br><span class="line">        <span class="comment">// 运行时间较长的代码，放到后台线程运行</span></span><br><span class="line">        dispatch_async(dispatch_get_main_queue()) &#123;</span><br><span class="line">            <span class="comment">// 结束后返回主线程操作 UI</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将工作放到其他线程虽然可以避免主线程阻塞，但它并不能减少这些代码实际的执行时间。进一步地，我们可以考虑改进算法和使用的数据结构来提高效率。根据实际项目中遇到的问题的不同，我们会有不同的解决方式，在这篇文章中，我们难以覆盖和深入去分析各种情况，所以这里我们只会提及一些共通的原则。</p>
<p>对于重复的工作，合理地利用缓存的方式可以极大提高效率，这是在优化时可以优先考虑的方式。Cocoa 开发中 <code>NSCache</code> 是专门用来管理缓存的一个类，合理地使用和配置 <code>NSCache</code> 把开发者中从管理缓存存储和失效的工作中解放出来。关于 <code>NSCache</code> 的详细使用方法，可以参看 <code>NSHipster</code> 关于这方面的<a target="_blank" rel="noopener" href="http://nshipster.com/nscache/">文章</a>以及 Apple 的<a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSCache_Class/">相关文档</a>。</p>
<p>在程序开发时，数据结构使用上的选择也是重要的一环。Swift 标准库提供了一些很基本的数据结构，比如 <code>Array</code>、<code>Dictionary</code> 和 <code>Set</code> 等。这些数据结构都是配合泛型的，在保证数据类型安全的同时，一般来说也能为我们提供足够的性能。关于这些数据的容器类型方法所对应的复杂度，Apple 都在标准库的文档或者注释中进行了标记。如果标准库所提供的类型和方法无法满足性能上的要求，或者没有符合业务需求的数据结构的话，那么考虑使用自己实现的数据结构也是可选项。</p>
<p>如果项目中有很多数学计算方面的工作导致了效率问题的话，考虑并行计算能极大改善程序性能。iOS 和 OS X 都有针对数学或者图形计算等数字信号处理方面进行了专门优化的框架：<a target="_blank" rel="noopener" href="https://developer.apple.com/library/tvos/documentation/Accelerate/Reference/AccelerateFWRef/index.html">Accelerate.framework</a>，利用相关的 API，我们可以轻松快速地完成很多经典的数字或者图像处理问题。因为这个框架只提供一组 C API，所以在 Swift 中直接使用会有一定困难。如果你的项目中要处理的计算相对简单的话，也可以使用 <a target="_blank" rel="noopener" href="https://github.com/mattt/Surge">Surge</a>，它是一个基于 Accelerate 框架的 Swift 项目，让我们能在代码里从并行计算中获得难以置信的性能提升。</p>
<h3 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h3><p>Swift 编译器十分智能，它能在编译期间帮助我们移除不需要的代码，或者将某些方法进行内联 (inline) 处理。编译器优化的强度可以在编译时通过参数进行控制，Xcode 工程默认情况下有 Debug 和 Release 两种编译配置，在 Debug 模式下，LLVM Code Generation 和 Swift Code Generation 都不开启优化，这能保证编译速度。而在 Release 模式下，LLVM 默认使用 “Fastest, Smallest [-Os]”，Swift Compiler 默认使用 “Fast [-O]”，作为优化级别。我们另外还有几个额外的优化级别可以选择，优化级别越高，编译器对于源码的改动幅度和开启的优化力度也就越大，同时编译期间消耗的时间也就越多。虽然绝大部分情况下没有问题，但是仍然需要当心的是，一些优化等级采用的是激进的优化策略，而禁用了一些检查。这可能在源码很复杂的情况下导致潜在的错误。如果你使用了很高的优化级别，请再三测试 Release 和 Debug 条件下程序运行的逻辑，以防止编译器优化所带来的问题。</p>
<p>值得一提的是，Swift 编译器有一个很有用的优化等级：”Fast, Whole Module Optimization”，也即 <code>-O -whole-module-optimization</code>。在这个优化等级下，Swift 编译器将会同时考虑整个 module 中所有源码的情况，并将那些没有被继承和重载的类型和方法标记为 <code>final</code>，这将尽可能地避免动态派发的调用，或者甚至将方法进行内联处理以加速运行。开启这个额外的优化将会大幅增加编译时间，所以应该只在应用要发布的时候打开这个选项。</p>
<p>虽然现在编译器在进行优化的时候已经足够智能了，但是在面对编写得非常复杂的情况时，很多本应实施的优化可能失效。因此保持代码的整洁、干净和简单，可以让编译器优化良好工作，以得到高效的机器码。</p>
<h3 id="尽量使用-Swift-类型"><a href="#尽量使用-Swift-类型" class="headerlink" title="尽量使用 Swift 类型"></a>尽量使用 Swift 类型</h3><p>为了和 Objective-C 协同工作，很多 Swift 标准库类型和对应的 Cocoa 类型是可以隐式的类型转换的，比如 <code>Swift.Array</code> 与 <code>NSArray</code>，<code>Swift.String</code> 和 <code>NSString</code> 等。虽然我们不需要在语言层面做类型转换，但是这个过程却不是免费的。在转换次数很多的时候，这往往会成为性能的瓶颈。一个常见的 Swift 和 Objective-C 混用的例子是 JSON 解析。考虑以下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData: <span class="type">NSData</span> <span class="operator">=</span> <span class="comment">//...</span></span><br><span class="line"><span class="keyword">let</span> jsonObject <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">NSJSONSerialization</span></span><br><span class="line">        .<span class="type">JSONObjectWithData</span>(jsonData, options: []) <span class="keyword">as?</span> [<span class="type">String</span>: <span class="type">AnyObject</span>]</span><br></pre></td></tr></table></figure>

<p>这是我们日常开发中很常见的代码，使用 <code>NSJSONSerialization</code> 将数据转换为 JSON 对象后，我们得到的是一个 NSObject 对象。在 Swift 中使用时，我们一般会先将其转换为 <code>[String: AnyObject]</code>，这个转换在一次性处理成千上万条 JSON 数据时会带来严重的性能退化。Swift 3 中我们可能可以基于 Swift 的 Foundation 框架来解决这个问题，但是现在，如果存在这样的情况，一种处理方式是避免使用 Swift 的字典类型，而使用 <code>NSDictionary</code>。另外，适当地使用 lazy 加载的方法，也是避免一次性进行过多的类型转换的好思路。</p>
<p>尽可能避免混合地使用 Swift 类型和 <code>NSObject</code> 子类，会对性能的提高有所帮助。</p>
<h3 id="避免无意义的-log，保持好的编码习惯"><a href="#避免无意义的-log，保持好的编码习惯" class="headerlink" title="避免无意义的 log，保持好的编码习惯"></a>避免无意义的 log，保持好的编码习惯</h3><p>在调试程序时，很多开发者喜欢用输出 log 的方式对代码的运行进行追踪，帮助理解。Swift 编译器并不会帮我们将 <code>print</code> 或者 <code>debugPrint</code> 删去，在最终 app 中它们会把内容输出到终端，造成性能的损失。我们当然可以在发布时用查找的方式将所有这些 log 输出语句删除或者注释掉，但是更好的方法是通过添加条件编译来将这些语句排除在 Release 版本外。在 Xcode 的 Build Setting 中，在 Other Swift flags 的 Debug 栏中加入 <code>-D DEBUG</code> 即可加入一个编译标识。</p>
<p>之后我们就可以通过将 <code>print</code> 或者 <code>debugPrint</code> 包装一下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">dPrint</span>(<span class="params">item</span>: <span class="keyword">Any</span>) &#123;</span><br><span class="line">    <span class="keyword">#if</span> <span class="type">DEBUG</span></span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line">    <span class="keyword">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，在 Release 版本中，<code>dPrint</code> 将会是一个空方法，所有对这个方法的调用都会被编译器剔除掉。需要注意的是，在这种封装下，如果你传入的 <code>items</code> 是一个表达式而不是直接的变量的话，这个表达式还是会被先执行求值的。如果这对性能也产生了可测的影响的话，我们最好用 <code>@autoclosure</code> 修饰参数来重新包装 <code>print</code>。这可以将求值运行推迟到方法内部，这样在 Release 时这个求值也会被一并去掉：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">dPrint</span>(<span class="keyword">@autoclosure</span> <span class="params">item</span>: () -&gt; <span class="keyword">Any</span>) &#123;</span><br><span class="line">    <span class="keyword">#if</span> <span class="type">DEBUG</span></span><br><span class="line">    <span class="built_in">print</span>(item())</span><br><span class="line">    <span class="keyword">#endif</span></span><br><span class="line">&#125;</span><br><span class="line">dPrint(resultFromHeavyWork())</span><br><span class="line"><span class="comment">// Release 版本中 resultFromHeavyWork() 不会被执行</span></span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Swift 还是一门很新的语言，并且处于高速发展中。因为现在 Swift 只用于 Cocoa 开发，因此它和 Cocoa 框架还有着千丝万缕的联系。很多时候由于这些原因，我们对于 Swift 性能的评估并不公正。这门语言本身设计就是以高性能为考量的，而随着 Swift 的开源和进一步的进化，以及配套框架的全面重写，相信在语言层面上我们能获得更好的性能和编译器的支持。</p>
<p>最好的优化就是不用优化。在软件开发中，保证书写正确简洁的代码，在项目开始阶段就注意可能存在的性能缺陷，将可扩展性的考虑纳入软件构建中，按照实际需求进行优化，不要陷入为了优化而优化的怪圈，这些往往都可以让我们避免额外的优化时间，让我们的工作得更加愉快。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="http://llvm.org/devmtg/2015-10/slides/GroffLattner-SILHighLevelIR.pdf">Swift Intermediate Language</a></li>
<li><a target="_blank" rel="noopener" href="http://nshipster.com/nscache/">NSCache - NSHipster</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSCache_Class/">NSCache 文档</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/mattt/Surge">Surge</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/12/21/swfitService/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qxy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一艘小船">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/21/swfitService/" class="post-title-link" itemprop="url">使用 Swift 搭建服务器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-12-21 11:04:00" itemprop="dateCreated datePublished" datetime="2016-12-21T11:04:00+08:00">2016-12-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="http://www.cocoachina.com/swift/20160318/15712.html">原文地址</a></p>
<p>自从苹果官方发布了一个 Swift 的 Linux 开源版本之后，服务端 Swift 终于迎来了一个令人激动的前景。我的好奇心终于无法克制，是时候尝试一下服务端 Swift 了！</p>
<p>除了用过几个 Baas 以外，我没有任何后端编程经验，但幸运的是开源社区已经提供了现成的框架。我试了一下 <a target="_blank" rel="noopener" href="https://twitter.com/tanner0101">Tanner Nelson</a> 推荐的 <a target="_blank" rel="noopener" href="https://github.com/qutheory/vapor">Vapor</a> 框架。它的使用非常简单，非常适合我当前的任务，在这篇文档中还会使用到 Heroku。我决定使用 Heroku 的原因是我们的后端团队在使用它，它对于前端来说非常友好。</p>
<p>写到这里的时候，为了解决 Heroku 框架运行中的几个小问题，我专门提交了一个 <a target="_blank" rel="noopener" href="https://github.com/qutheory/vapor/pull/25">pull request</a> 。如果代码还没被合并的话，请设置你的包管理器从 <a target="_blank" rel="noopener" href="https://github.com/loganwright/vapor">这里</a> 下载。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>要继续本教程，首先，你需要一个 <a target="_blank" rel="noopener" href="https://signup.heroku.com/?c=70130000001x9jFAAQ">Heroku</a> 账号 ，并安装好 <a target="_blank" rel="noopener" href="https://swift.org/download/">Swift Development Snapshot</a> 。写到这里的时候，在它的正式版中还未包含 swift 包管理器。因此为了使用这个工具，你必须下载开发版的 snapshot。</p>
<h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><p>我们的目标是创建一个简单的 Swift 服务器并运行在 Heroku 上。这不需要在 linux 环境下进行，就像是你在使用本地服务器。你只消创建一个本地的 Xcode 项目，对项目进行一些设置，然后就可以在 <a target="_blank" rel="noopener" href="https://swift.org/package-manager/">Swift 包管理器</a> 中运行它。整过过程分为 4 个步骤：</p>
<p>####### 将 main.swift 拷贝根目录下的 Sources 目录</p>
<p><a href = "/img/swfitService/swiftService1.png"><img src = "/img/swfitService/swiftService1.png" width = 720 height = 598 alt = "swiftService1.png"/></a></p>
<p>####### 创建一个 Package.swift 文件</p>
<p><a href = "/img/swfitService/swiftService2.png"><img src = "/img/swfitService/swiftService2.png" width = 720 height = 218 alt = "swiftService2.png"/></a></p>
<p>####### 将 .build 目录添加到 import paths </p>
<p>要使用自动补全和语法加亮功能，需要将 Swift 包管理器的 build 目录提交到 import paths 中。注意，在 import paths 的 Debug 中设置的 debug 目录，而 Release 项则输入 release 目录。</p>
<p><a href = "/img/swfitService/swiftService3.png"><img src = "/img/swfitService/swiftService3.png" width = 720 height = 334 alt = "swiftService3.png"/></a></p>
<p>####### 用 toolchain 运行 Xcode</p>
<p>如果你使用 Xcode 7.3，你可以用 Xcode &gt; Toolchains 菜单开启一个Xcode 实例，用于打开 swift snapshot。因为我们不能在 Xcode 中进行编译，我们只能以命令行的方式进行编译。</p>
<p><a href = "/img/swfitService/swiftServie4.png"><img src = "/img/swfitService/swiftService4.png" width = 594 height = 16 alt = "swiftService4.png"/></a></p>
<h4 id="编写服务器"><a href="#编写服务器" class="headerlink" title="编写服务器"></a>编写服务器</h4><p>令我高兴的是，为了进行概念验证，我需要编写的代码其实只有寥寥数行。我启动和运行服务器的代码甚至不到 10 行。</p>
<p><a href = "/img/swfitService/swiftServie5.png"><img src = "/img/swfitService/swiftService5.png" width = 720 height = 239 alt = "swiftService5.png"/></a></p>
<p>要启动服务器，只需在终端中输入一句命令，：</p>
<p><a href = "/img/swfitService/swiftService6.png"><img src = "/img/swfitService/swiftService6.png" width = 720 height = 126 alt = "swiftService6.png"/></a></p>
<p>好了，让我们打开浏览器。我的浏览器安装了 json 插件，你的画面或许会有不同。</p>
<p><a href = "/img/swfitService/swiftService7.png"><img src = "/img/swfitService/swiftService7.png" width = 556 height = 240 alt = "swiftService7.png"/></a></p>
<h4 id="迁移到云上"><a href="#迁移到云上" class="headerlink" title="迁移到云上"></a>迁移到云上</h4><p>服务器在本地顺利运行起来了，但如果放到云端则更好。我迫不及待地想将 App 在云上跑起来。对于我来说这是一个全新的挑战，幸运的是，我得到了 <a target="_blank" rel="noopener" href="https://twitter.com/vincenttoms">Vincent Toms</a> 的悉心指导。</p>
<p>Heroku 的安装是一件非常愉悦的体验，几分钟后我就创建了一个 Heroku App，接下来我就要上传我的项目了。</p>
<p>####### 出错啦</p>
<p>这只是今天的诸多错误中的一个。我已经预计到事情不可能一帆风顺，因此我查看了 Vapor 的文档，最终发现问题出在所谓的 <a target="_blank" rel="noopener" href="https://devcenter.heroku.com/articles/buildpacks">buildpacks</a> 上。Heorku 提供了一些标准的 buildpacks，但完全没有针对 Swift 的 buildpacks。无奈之下求救于开源社区，刚好看到 Kyle Fuller 的 <a target="_blank" rel="noopener" href="https://github.com/kylef/heroku-buildpack-swift">buildpack</a> 。集成它就简单得多了。</p>
<p><a href = "/img/swfitService/swiftService8.png"><img src = "/img/swfitService/swiftService8.png" width = 720 height = 85 alt = "swiftService8.png"/></a></p>
<p>用这个 buildpack 启动后，App 成功加载，接下来就是访问它的 URL。</p>
<p>####### 再次出错</p>
<p><a href = "/img/swfitService/swiftService9.png"><img src = "/img/swfitService/swiftService9.png" width = 720 height = 147 alt = "swiftService9.png"/></a></p>
<p>事情不会那么顺利的，是吧？经过 google 一番，仔细查看了一些例子，我发现我还差一个 Procfile。浏览一下这个文件的内容，你就能明白这个文件是干什么用的了。</p>
<p><a href = "/img/swfitService/swiftService10.png"><img src = "/img/swfitService/swiftService10.png" width = 664 height = 170 alt = "swiftService10.png"/></a></p>
<p>buildpack 创建了可执行文件，但 Heroku 并不知道。通过 Procfile，我们告诉 Heroku 去运行 SwiftServerIO 可执行文件。上传这个 Procfile。</p>
<p>####### 仍然出错</p>
<p>Heroku 编译的 2 分支仿佛变得无比漫长。我重新打开了浏览器，发现仍然报错。</p>
<p><a href = "/img/swfitService/swiftService11.png"><img src = "/img/swfitService/swiftService11.png" width = 720 height = 153 alt = "swiftService11.png"/></a></p>
<p>我以为 Heroku 可能还未启动完成（实际不是），因此我又等了一小会，终于发现出错了。可执行文件生成了， process file 也就绪，一定是别的什么地方出问题了。再次 google，一直到我最终发现我需要设置 App 的规模(<a target="_blank" rel="noopener" href="https://devcenter.heroku.com/articles/scaling#cli">scale up</a>)。这要使用到 Heroku 的 toolbelt 中的一个简单命令。</p>
<p>heroku ps:scale web&#x3D;1</p>
<p>Heroku 在免费情况下只有一个 dyno（Heroku 计费单位，10~50 个请求&#x2F;秒）。但对于我们的简单服务器来说，这也够了。因此，在我们将 scale web 设置为 1 个 dyno 之后，再次用浏览器查看。</p>
<p>成功了！</p>
<p><a href = "/img/swfitService/swiftService13.png"><img src = "/img/swfitService/swiftService13.png" width = 168 height = 166 alt = "swiftService13.png" /></a></p>
<p>成功了！服务器启动，出现了万能的 hello world！经过一番欢呼雀跃之后，让我们真正来问一声好吧！</p>
<p>####### 响应请求</p>
<p>在 main.swfit 文件中添加一小段代码，让服务器在问好的同时能够因人而异。就微微偷一下懒，新加一个路由，让服务器根据输入输出不同的问候语。</p>
<p><a href = "/img/swfitService/swiftService14.png"><img src = "/img/swfitService/swiftService14.png" width = 720 height = 296 alt = "swiftService14.png" /></a></p>
<p>一切正常，但根据一般规律，我仍然做好了出错的心理准备。提交修改，push 代码到 Heroku。</p>
<p>####### Say Hello!</p>
<p><a href = "/img/swfitService/swiftService15.png"><img src = "/img/swfitService/swiftService15.png" width = 413 height = 151 alt = "swiftService15.png" /></a></p>
<p>大约一份多钟的编译之后，在浏览器中访问 URL，服务器返回了问候语。<a target="_blank" rel="noopener" href="http://swift-server-io.herokuapp.com/hello/reader">你可以在这里查看效果</a> 。</p>
<p>接下来是什么？</p>
<p>可以说，服务端 Swift 的今天离不开社区强大支持。对于我来说，能够从云端获取 JSON 是一个令人兴奋的开始，我已经迫不及待地想看看接下来还会发生什么。</p>
<p>当然在此之前，我不得不和我在 <a target="_blank" rel="noopener" href="http://intrepid.io/">Intrepid Pursuits</a> 的同事们一起，继续编写一个有一个 iOS App。如果你想了解我的最新动态，请在访问我的 <a target="_blank" rel="noopener" href="https://github.com/loganwright">Github</a> 或者 <a target="_blank" rel="noopener" href="https://twitter.com/logmaestro">Twitter</a>。</p>
<p><a target="_blank" rel="noopener" href="http://www.swiftserver.io/hello/server-side-swift">服务端 Swift</a> </p>
<p>附言</p>
<p>在 <a target="_blank" rel="noopener" href="https://github.com/loganwright/vapor">这里</a> 下载源代码。</p>
<p>在 <a target="_blank" rel="noopener" href="https://github.com/LoganWright/swift-server-io/tree/master/Journal">Journal</a> 文件夹中，是 step-by-step 指南。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/10/28/iOSUseFFmpeg/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qxy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一艘小船">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/10/28/iOSUseFFmpeg/" class="post-title-link" itemprop="url">iOS 配置FFmpeg框架</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-10-28 16:21:00" itemprop="dateCreated datePublished" datetime="2016-10-28T16:21:00+08:00">2016-10-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>FFmpeg</strong>是一个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E8%BB%9F%E9%AB%94">自由软件</a>，可以运行音频和视频多种格式的<a target="_blank" rel="noopener" href="http://ffmpeg.org/ffmpeg.html">录影、转换、流功能</a>，包含了libavcodec——这是一个用于多个项目中音频和视频的解码器库，以及libavformat——一个音频与视频格式转换库。</p>
<h2 id="环境与工具"><a href="#环境与工具" class="headerlink" title="环境与工具"></a>环境与工具</h2><p><strong>Mac OS X EI Capitan 10.11.4</strong><br><strong>Xcode7.3.1</strong><br><strong>终端</strong></p>
<h3 id="1-安装-yasm"><a href="#1-安装-yasm" class="headerlink" title="1.安装 yasm"></a>1.安装 <a target="_blank" rel="noopener" href="http://yasm.tortall.net/releases/Release1.3.0.html">yasm</a></h3><p>*OS X 下载 Source .tar.gz 即可 *</p>
<p>下载完成后，打开终端，cd 进目录</p>
<pre><code>$ ./configure
$ make
$ make install
</code></pre>
<p>安装完成后验证，显示如下表明安装成功</p>
<pre><code>$ yasm --version
yasm 1.3.0
Compiled on May 12 2016.
Copyright (c) 2001-2014 Peter Johnson and other Yasm developers.
Run yasm --license for licensing overview and summary.
</code></pre>
<h3 id="2-下载-gas-preprocessor-pl"><a href="#2-下载-gas-preprocessor-pl" class="headerlink" title="2.下载 gas-preprocessor.pl"></a>2.下载 <a target="_blank" rel="noopener" href="https://github.com/libav/gas-preprocessor">gas-preprocessor.pl</a></h3><p>复制 <code>gas-preprocessor.pl</code> 到 <code>/usr/local/bin</code> 下 <strong>(网上很多教程都让放在 <code>/usr/bin</code> 下，但是现在OS X的 <code>usr/bin</code> 目录不可写，所以放在 <code>/usr/local/bin</code> )</strong></p>
<p>修改文件权限 </p>
<pre><code>$ chmod 777 /usr/local/bin/gas-preprocessor.pl
</code></pre>
<h3 id="3-下载脚本文件"><a href="#3-下载脚本文件" class="headerlink" title="3.下载脚本文件"></a>3.下载<a target="_blank" rel="noopener" href="https://github.com/kewlbear/FFmpeg-iOS-build-script">脚本文件</a></h3><p>这个脚本可以一次编译，就生成适合各个框架的静态库。</p>
<p>解压后 cd 进目录 ，执行</p>
<pre><code>$ ./build-ffmpeg.sh
</code></pre>
<p>脚本则会自动从github中把ffmpeg源码下到本地并开始编译。 编译结束后，文件目录如下：</p>
<p><img src="/img/SettingFFmpeg/SettingFFmpeg_list.png?raw=true" alt="SettingFFmpeg"></p>
<p>ffmpeg-3.0是源码， FFmpeg-iOS是编译出来的库，里面是我们需要的.a 静态库，一共有7个。 终端输入</p>
<pre><code>$ lipo -info libavcodec.a 
Architectures in the fat file: libavcodec.a are: armv7 i386 x86_64 arm64 
</code></pre>
<p>可以看出来静态库支持 <code>armv7</code>  <code>i386</code>  <code>x86_64</code>  <code>arm64 </code> 构架</p>
<h3 id="4-把-FFmpeg-iOS-导入工程。"><a href="#4-把-FFmpeg-iOS-导入工程。" class="headerlink" title="4.把 FFmpeg-iOS 导入工程。"></a>4.把 FFmpeg-iOS 导入工程。</h3><p>然后在 <code>Build Settings</code> 中找到 <code>Search Paths</code> ，设置 <code>Header Search Pahts</code> 和 <code>Library Search Paths</code> 如下。不然会报 <code>include“libavformat/avformat.h” file not found </code> 错误。</p>
<p><img src="/img/SettingFFmpeg/SettingFFmpeg_header.png?raw=true" alt="SettingFFmpeg_header"></p>
<p><img src="/img/SettingFFmpeg/SettingFFmpeg_library.png?raw=true" alt="SettingFFmpeg_library"></p>
<h3 id="5-在工程中导入其他库文件。"><a href="#5-在工程中导入其他库文件。" class="headerlink" title="5.在工程中导入其他库文件。"></a>5.在工程中导入其他库文件。</h3><p><code>libz.tbd</code> 、<code>ibbz2.tbd</code> 、 <code>libiconv.tbd</code>,在 3.0以后需要添加另外2个框架 <code>VideoToolbox.framework</code> 和 <code>CoreMedia.framework</code></p>
<h3 id="5-编译"><a href="#5-编译" class="headerlink" title="5.编译"></a>5.编译</h3><p>因为这些库是C++，所以需要把一个文件后缀改为 .mm，这样Xcode就会自动打开C++混编，一般会把  <code>AppDelegate.m</code> 改为 <code>AppDelegate.mm</code> </p>
<p>然后随便找个 文件，导入 <code>avcodec.h</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;avcodec.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">   [<span class="variable language_">super</span> viewDidLoad];    </span><br><span class="line">   avcodec_register_all();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以运行起来说明配置成功。</p>
<p>这里放一个<a target="_blank" rel="noopener" href="https://github.com/qiangxinyu/XYFFmpeg">Demo</a></p>
<h3 id="6-可能出现的问题"><a href="#6-可能出现的问题" class="headerlink" title="6.可能出现的问题"></a>6.可能出现的问题</h3><ul>
<li><p>执行 .sh 文件不成功</p>
<p>$ .&#x2F;build-ffmpeg.sh<br>-bash: .&#x2F;build-ffmpeg.sh: No such file or directory</p>
</li>
</ul>
<p>这种类型的错误是找不到 <code>build-ffmpeg.sh</code> 文件，先看看路径对不对，然后再看下里面有没有这个文件，在安装 <code>yasm</code> 的时候我第一次是在 <code>github</code> 上下载的一个，里面没有 <code>.sh</code> 文件，导致无法执行。</p>
<ul>
<li><p>Xcode编译报错</p>
<p> Undefined symbols for architecture x86_64: (或者armv7之类的)<br> …<br> ld: symbol(s) not found for architecture x86_64<br> clang: error: linker command failed with exit code 1 (use -v to see invocation)</p>
</li>
</ul>
<p>这种一般都是因为缺少依赖，检查一下上述那3个库和2个框架是否正确添加。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a target="_blank" rel="noopener" href="http://cnbin.github.io/blog/2015/05/19/iospei-zhi-ffmpegkuang-jia/">http://cnbin.github.io/blog/2015/05/19/iospei-zhi-ffmpegkuang-jia/</a></li>
<li><a target="_blank" rel="noopener" href="http://bbs.iosre.com/t/10-11-usr-bin-class-dump/1936/5">http://bbs.iosre.com/t/10-11-usr-bin-class-dump/1936/5</a></li>
<li><a target="_blank" rel="noopener" href="http://www.jianshu.com/p/147c03553e63">http://www.jianshu.com/p/147c03553e63
</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/liyufeng2013/p/4286684.html">http://www.cnblogs.com/liyufeng2013/p/4286684.html
</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/10/16/WKWebView/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qxy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一艘小船">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/10/16/WKWebView/" class="post-title-link" itemprop="url">WKWebView</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-10-16 16:23:00" itemprop="dateCreated datePublished" datetime="2016-10-16T16:23:00+08:00">2016-10-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>WKWebView</code> 是苹果在 iOS 8 中引入的新组件，目的是给出一个新的高性能的 <code>Web View</code> 解决方案，摆脱过去 <code>UIWebView </code> 的老旧笨重特别是内存占用量巨大的问题。</p>
<p>苹果将 <code>UIWebViewDelegate</code> 与 <code>UIWebView</code> 重构成了 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/WebKit/ObjC_classic/index.html">14 个类和 3 个协议</a>，引入了不少新的功能和接口，这可以在一定程度上看做苹果对其封锁 <code>Web View</code> 内核的行为作出的补偿：既然你们都说 <code>UIWebView</code> 太渣，那我就造一个不渣的给你们用呗~~ 众所周知，连 Chrome 的 iOS 版用的也是 <code>UIWebView</code> 的内核。</p>
<p><code>WKWebView</code> 有以下几大主要进步：</p>
<ul>
<li>浏览器内核渲染进程提取出 App，由系统进行统一管理，这减少了相当一部分的性能损失。</li>
<li>js 可以直接使用已经事先注入 js runtime 的 js 接口给 Native 层传值，不必再通过苦逼的 iframe 制造页面刷新再解析自定义协议的奇怪方式。</li>
<li>支持高达 60 fps 的滚动刷新率，内置了手势探测。</li>
</ul>
<h6 id="开始使用-WKWebView"><a href="#开始使用-WKWebView" class="headerlink" title=" 开始使用 WKWebView "></a><font color = #1ba856 > 开始使用 WKWebView </font></h6><p>创建一个名为 BuildYourOwnHybridDevelopmentFramework 的 Single View Application 项目。在 <code>ViewController</code> 顶部引入 <code>WebKit</code>：</p>
<p><code>import WebKit</code></p>
<p>之后创建一个 WKWebView 类型的成员变量，并对其进行初始化，加入到页面上：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wk: <span class="type">WKWebView</span>!</span><br><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">viewDidLoad</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">didReceiveMemoryWarning</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">    <span class="comment">// Dispose of any resources that can be recreated.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">viewDidAppear</span>(<span class="params">animated</span>: <span class="type">Bool</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidAppear(animated)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.wk <span class="operator">=</span> <span class="type">WKWebView</span>(frame: <span class="keyword">self</span>.view.frame)</span><br><span class="line">    <span class="keyword">self</span>.wk.loadRequest(<span class="type">NSURLRequest</span>(URL: <span class="type">NSURL</span>(string: <span class="string">&quot;http://www.baidu.com/&quot;</span>)<span class="operator">!</span>))</span><br><span class="line">    <span class="keyword">self</span>.view.addSubview(<span class="keyword">self</span>.wk)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遭遇 BUG</p>
<p>如果你用的是 Xcode 7，这时候你应该得到了一块雪白雪白的屏幕，我们遭遇了 bug。这是因为 iOS 9 SDK 中默认不再支持访问非 HTTPS 的地址，在 <code>info.plist</code> 加入:</p>
<figure class="highlight plist"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>NSAppTransportSecurity<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>NSAllowsArbitraryLoads<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>再次运行项目，搞定！</p>
<p>查看效果</p>
<p><a href = "/img/WKWebView/WKWebView_0.png"><img src = "/img/WKWebView/WKWebView_0.png" width = 365 height = 690 alt = "WKWebView_0.png"></a></p>
<h6 id="简易错误处理-WKWebView"><a href="#简易错误处理-WKWebView" class="headerlink" title=" 简易错误处理 WKWebView "></a><font color = #1ba856 > 简易错误处理 WKWebView </font></h6><p>为了更方便地在开发中调试问题，我们需要处理一下页面加载失败的事件。</p>
<p>加入代理：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ViewController</span>: <span class="title class_">UIViewController</span>, <span class="title class_">WKNavigationDelegate</span> &#123;</span><br><span class="line"><span class="operator">...</span> <span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>设置代理对象为 self：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.wk.navigationDelegate <span class="operator">=</span> <span class="keyword">self</span></span><br></pre></td></tr></table></figure>

<p>处理加载失败事件</p>
<p>我们可以使用以下方式让 View Controller 更优雅，更短小精悍：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">typealias</span> wkNavigationDelegate <span class="operator">=</span> <span class="type">ViewController</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">wkNavigationDelegate</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">webView</span>(<span class="params">webView</span>: <span class="type">WKWebView</span>, <span class="params">didFailNavigation</span> <span class="params">navigation</span>: <span class="type">WKNavigation</span>!,</span><br><span class="line">     <span class="params">withError</span> <span class="params">error</span>: <span class="type">NSError</span>) &#123;</span><br><span class="line">        <span class="type">NSLog</span>(error.debugDescription)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">webView</span>(<span class="params">webView</span>: <span class="type">WKWebView</span>, <span class="params">didFailProvisionalNavigation</span> </span><br><span class="line">    <span class="params">navigation</span>: <span class="type">WKNavigation</span>!, <span class="params">withError</span> <span class="params">error</span>: <span class="type">NSError</span>) &#123;</span><br><span class="line">        <span class="type">NSLog</span>(error.debugDescription)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看效果</p>
<p>我们把 网址从 <a target="_blank" rel="noopener" href="http://www.baidu.com/">http://www.baidu.com/</a> 改成 <a target="_blank" rel="noopener" href="http://www.baidu/">http://www.baidu/</a>，运行，得到错误：</p>
<p><a href = "/img/WKWebView/WKWebView_1.png"><img src = "/img/WKWebView/WKWebView_1.png" width = 545 height = 114 alt = "WKWebView_1.png"></a></p>
<p>搞定！</p>
<h6 id="显示弹窗-WKWebView"><a href="#显示弹窗-WKWebView" class="headerlink" title=" 显示弹窗 WKWebView "></a><font color = #1ba856 > 显示弹窗 WKWebView </font></h6><p>在 UIWebView 里，js 的 alert() 弹窗会自动以系统弹窗的形式展示，但是 WKWebview 把这个接口也暴露给了我们，让我们自己 handle js 传来的 alert()。下面我们将自己写代码 handle 住这个事件，并展示为系统弹窗。</p>
<p>加入代理：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ViewController</span>: <span class="title class_">UIViewController</span>, <span class="title class_">WKNavigationDelegate</span>, <span class="title class_">WKUIDelegate</span> &#123;</span><br><span class="line"><span class="operator">...</span> <span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>设置代理对象为 self：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.wk.<span class="type">UIDelegate</span> <span class="operator">=</span> <span class="keyword">self</span></span><br></pre></td></tr></table></figure>


<p>处理 alert() 事件</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">typealias</span> wkUIDelegate <span class="operator">=</span> <span class="type">ViewController</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">wkUIDelegate</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">webView</span>(<span class="params">webView</span>: <span class="type">WKWebView</span>, <span class="params">runJavaScriptAlertPanelWithMessage</span> <span class="params">message</span>: <span class="type">String</span>,</span><br><span class="line">     <span class="params">initiatedByFrame</span> <span class="params">frame</span>: <span class="type">WKFrameInfo</span>, <span class="params">completionHandler</span>: () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> ac <span class="operator">=</span> <span class="type">UIAlertController</span>(title: webView.title, message: message, preferredStyle:</span><br><span class="line">         <span class="type">UIAlertControllerStyle</span>.<span class="type">Alert</span>)</span><br><span class="line">        ac.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">&quot;OK&quot;</span>, style: <span class="type">UIAlertActionStyle</span>.<span class="type">Cancel</span>, handler:</span><br><span class="line">         &#123; (aa) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">            completionHandler()</span><br><span class="line">        &#125;))</span><br><span class="line">        <span class="keyword">self</span>.presentViewController(ac, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 alert()</p>
<p>把网址改为正确的 <a target="_blank" rel="noopener" href="http://www.baidu.com/">http://www.baidu.com/</a>，运行项目。然后使用 Safari 自带的 Web View 调试工具执行 alert() 函数：</p>
<p><a href = "/img/WKWebView/WKWebView_2.png"><img src = "/img/WKWebView/WKWebView_2.png" width = 455 height = 262 alt = "WKWebView_2.png"></a></p>
<p>查看效果</p>
<p><a href = "/img/WKWebView/WKWebView_3.png"><img src = "/img/WKWebView/WKWebView_3.png" width = 546 height = 410 alt = "WKWebView_3.png"></a></p>
<p>OK</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/09/20/understandingRunloop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qxy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一艘小船">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/09/20/understandingRunloop/" class="post-title-link" itemprop="url">深入理解Runloop</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-09-20 16:02:00" itemprop="dateCreated datePublished" datetime="2016-09-20T16:02:00+08:00">2016-09-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转载自<a target="_blank" rel="noopener" href="http://blog.ibireme.com/2015/05/18/runloop/">YY大神</a></p>
<p>RunLoop 是 iOS 和 OSX 开发中非常基础的一个概念，这篇文章将从 CFRunLoop 的源码入手，介绍 RunLoop 的概念以及底层实现原理。之后会介绍一下在 iOS 中，苹果是如何利用 RunLoop 实现自动释放池、延迟回调、触摸事件、屏幕刷新等功能的。</p>
<h2 id="RunLoop-的概念"><a href="#RunLoop-的概念" class="headerlink" title="RunLoop 的概念"></a>RunLoop 的概念</h2><p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">    initialize();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var message = get_next_message();</span><br><span class="line">        process_message(message);</span><br><span class="line">    &#125; <span class="keyword">while</span> (message != quit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种模型通常被称作 Event Loop。 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Event_loop">Event Loop</a> 在很多系统和框架里都有实现，比如 Node.js 的事件处理，比如 Windows 程序的消息循环，再比如 OSX&#x2F;iOS 里的 RunLoop。实现这种模型的关键点在于：如何管理事件&#x2F;消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。</p>
<p>所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。</p>
<p>OSX&#x2F;iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。<br>CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。<br>NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</p>
<p>CFRunLoopRef 的代码是<a target="_blank" rel="noopener" href="http://opensource.apple.com/source/CF/CF-855.17/CFRunLoop.c">开源</a>的，你可以在这里 <a target="_blank" rel="noopener" href="http://opensource.apple.com/tarballs/CF/">http://opensource.apple.com/tarballs/CF/</a> 下载到整个 CoreFoundation 的源码来查看。</p>
<p>(Update: Swift 开源后，苹果又维护了一个跨平台的 CoreFoundation 版本：<a target="_blank" rel="noopener" href="https://github.com/apple/swift-corelibs-foundation/">https://github.com/apple/swift-corelibs-foundation/</a>，这个版本的源码可能和现有 iOS 系统中的实现略不一样，但更容易编译，而且已经适配了 Linux&#x2F;Windows。)</p>
<h2 id="RunLoop-与线程的关系"><a href="#RunLoop-与线程的关系" class="headerlink" title="RunLoop 与线程的关系"></a>RunLoop 与线程的关系</h2><p>首先，iOS 开发中能遇到两个线程对象: pthread_t 和 NSThread。过去苹果有份<a target="_blank" rel="noopener" href="http://www.fenestrated.net/~macman/mirrors/Apple%20Technotes%20(As%20of%202002)/tn/tn2028.html">文档</a>标明了 NSThread 只是 pthread_t 的封装，但那份文档已经失效了，现在它们也有可能都是直接包装自最底层的 mach thread。苹果并没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是 pthread_t 和 NSThread 是一一对应的。比如，你可以通过 pthread_main_thread_np() 或 [NSThread mainThread] 来获取主线程；也可以通过 pthread_self() 或 [NSThread currentThread] 来获取当前线程。CFRunLoop 是基于 pthread 来管理的。</p>
<p>苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。 这两个函数内部的逻辑大概是下面这样:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CFMutableDictionaryRef</span> loopsDic;</span><br><span class="line"><span class="comment">/// 访问 loopsDic 时的锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CFSpinLock_t</span> loopsLock;</span><br><span class="line"><span class="comment">/// 获取一个 pthread 对应的 RunLoop。</span></span><br><span class="line"><span class="built_in">CFRunLoopRef</span> _CFRunLoopGet(pthread_t thread) &#123;</span><br><span class="line">    OSSpinLockLock(&amp;loopsLock);</span><br><span class="line">    <span class="keyword">if</span> (!loopsDic) &#123;</span><br><span class="line">        <span class="comment">// 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。</span></span><br><span class="line">        loopsDic = <span class="built_in">CFDictionaryCreateMutable</span>();</span><br><span class="line">        <span class="built_in">CFRunLoopRef</span> mainLoop = _CFRunLoopCreate();</span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(loopsDic, pthread_main_thread_np(), mainLoop);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">/// 直接从 Dictionary 里获取。</span></span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> loop = <span class="built_in">CFDictionaryGetValue</span>(loopsDic, thread));</span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">        <span class="comment">/// 取不到时，创建一个</span></span><br><span class="line">        loop = _CFRunLoopCreate();</span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(loopsDic, thread, loop);</span><br><span class="line">        <span class="comment">/// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span></span><br><span class="line">        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    OSSpinLockUnLock(&amp;loopsLock);</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetMain</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> _CFRunLoopGet(pthread_main_thread_np());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetCurrent</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> _CFRunLoopGet(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出，线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p>
<h2 id="RunLoop-对外的接口"><a href="#RunLoop-对外的接口" class="headerlink" title="RunLoop 对外的接口"></a>RunLoop 对外的接口</h2><p>在 CoreFoundation 里面关于 RunLoop 有5个类:</p>
<p>CFRunLoopRef<br>CFRunLoopModeRef<br>CFRunLoopSourceRef<br>CFRunLoopTimerRef<br>CFRunLoopObserverRef</p>
<p>其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:</p>
<p><a href="/img/understandingRunloop/RunLoop_0.png"><img src = "/img/understandingRunloop/RunLoop_0.png" width = 455 height = 357 alt = "RunLoop_0.png" /></a></p>
<p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source&#x2F;Timer&#x2F;Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source&#x2F;Timer&#x2F;Observer，让其互不影响。</p>
<p>CFRunLoopSourceRef 是事件产生的地方。Source有两个版本：Source0 和 Source1。<br>• Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。<br>• Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</p>
<p>CFRunLoopTimerRef 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p>
<p>CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_OPTIONS</span>(<span class="built_in">CFOptionFlags</span>, <span class="built_in">CFRunLoopActivity</span>) &#123;</span><br><span class="line">    kCFRunLoopEntry         = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>), <span class="comment">// 即将进入Loop</span></span><br><span class="line">    kCFRunLoopBeforeTimers  = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>), <span class="comment">// 即将处理 Timer</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>), <span class="comment">// 即将处理 Source</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">5</span>), <span class="comment">// 即将进入休眠</span></span><br><span class="line">    kCFRunLoopAfterWaiting  = (<span class="number">1</span>UL &lt;&lt; <span class="number">6</span>), <span class="comment">// 刚从休眠中唤醒</span></span><br><span class="line">    kCFRunLoopExit          = (<span class="number">1</span>UL &lt;&lt; <span class="number">7</span>), <span class="comment">// 即将退出Loop</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>上面的 Source&#x2F;Timer&#x2F;Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p>
<h2 id="RunLoop-的-Mode"><a href="#RunLoop-的-Mode" class="headerlink" title="RunLoop 的 Mode"></a>RunLoop 的 Mode</h2><p>CFRunLoopMode 和 CFRunLoop 的结构大致如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __CFRunLoopMode &#123;</span><br><span class="line">    <span class="built_in">CFStringRef</span> _name;            <span class="comment">// Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources0;    <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources1;    <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _observers; <span class="comment">// Array</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _timers;    <span class="comment">// Array</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> __CFRunLoop &#123;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes;     <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems; <span class="comment">// Set&lt;Source/Observer/Timer&gt;</span></span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> _currentMode;    <span class="comment">// Current Runloop Mode</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _modes;           <span class="comment">// Set</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source&#x2F;Observer&#x2F;Timer 同步到具有 “Common” 标记的所有Mode里。</p>
<p>应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。</p>
<p>有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。</p>
<p>CFRunLoop对外暴露的管理 Mode 接口只有下面2个:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopAddCommonMode</span>(<span class="built_in">CFRunLoopRef</span> runloop, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopRunInMode</span>(<span class="built_in">CFStringRef</span> modeName, ...);</span><br></pre></td></tr></table></figure>


<p>Mode 暴露的管理 mode item 的接口有下面几个:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopAddSource</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopSourceRef</span> source, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopAddTimer</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopTimerRef</span> timer, <span class="built_in">CFStringRef</span> mode);</span><br><span class="line"><span class="built_in">CFRunLoopRemoveSource</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopSourceRef</span> source, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopRemoveObserver</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopRemoveTimer</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopTimerRef</span> timer, <span class="built_in">CFStringRef</span> mode);</span><br></pre></td></tr></table></figure>


<p>你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。</p>
<p>苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。</p>
<p>同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。</p>
<h2 id="RunLoop-的内部逻辑"><a href="#RunLoop-的内部逻辑" class="headerlink" title="RunLoop 的内部逻辑"></a>RunLoop 的内部逻辑</h2><p>根据苹果在<a target="_blank" rel="noopener" href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23">文档</a>里的说明，RunLoop 内部的逻辑大致如下:</p>
<p><a href="/img/understandingRunloop/RunLoop_1.png"><img src = "/img/understandingRunloop/RunLoop_1.png" width = 647 height = 497 alt = "RunLoop_1.png" /></a></p>
<p>其内部代码整理如下 （太长了不想看可以直接跳过去，后面会有说明）：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 用DefaultMode启动</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">CFRunLoopRun</span>(<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 用指定的Mode启动，允许设置RunLoop超时时间</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">CFRunLoopRunInMode</span>(<span class="built_in">CFStringRef</span> modeName, <span class="built_in">CFTimeInterval</span> seconds, Boolean stopAfterHandle) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// RunLoop的实现</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">CFRunLoopRunSpecific</span>(runloop, modeName, seconds, stopAfterHandle) &#123;</span><br><span class="line">    <span class="comment">/// 首先根据modeName找到对应mode</span></span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> currentMode = __CFRunLoopFindMode(runloop, modeName, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">/// 如果mode里没有source/timer/observer, 直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(currentMode)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/// 1. 通知 Observers: RunLoop 即将进入 loop。</span></span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class="line">    <span class="comment">/// 内部函数，进入loop</span></span><br><span class="line">    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line">        Boolean sourceHandledThisLoop = <span class="literal">NO</span>;</span><br><span class="line">        <span class="type">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">/// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span></span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line">            <span class="comment">/// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span></span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">            <span class="comment">/// 执行被加入的block</span></span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">            <span class="comment">/// 4. RunLoop 触发 Source0 (非port) 回调。</span></span><br><span class="line">            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</span><br><span class="line">            <span class="comment">/// 执行被加入的block</span></span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">            <span class="comment">/// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span></span><br><span class="line">            <span class="keyword">if</span> (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</span><br><span class="line">                <span class="keyword">if</span> (hasMsg) <span class="keyword">goto</span> handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span></span><br><span class="line">            <span class="keyword">if</span> (!sourceHandledThisLoop) &#123;</span><br><span class="line">                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span></span><br><span class="line">            <span class="comment">/// • 一个基于 port 的Source 的事件。</span></span><br><span class="line">            <span class="comment">/// • 一个 Timer 到时间了</span></span><br><span class="line">            <span class="comment">/// • RunLoop 自身的超时时间到了</span></span><br><span class="line">            <span class="comment">/// • 被其他什么调用者手动唤醒</span></span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">                mach_msg(msg, MACH_RCV_MSG, port); <span class="comment">// thread wait for receive msg</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span></span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line">            <span class="comment">/// 收到消息，处理消息。</span></span><br><span class="line">            handle_msg:</span><br><span class="line">            <span class="comment">/// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span></span><br><span class="line">            <span class="keyword">if</span> (msg_is_timer) &#123;</span><br><span class="line">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">/// 9.2 如果有dispatch到main_queue的block，执行block。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (msg_is_dispatch) &#123;</span><br><span class="line">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">/// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">CFRunLoopSourceRef</span> source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class="line">                <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">                    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/// 执行加入到Loop的block</span></span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">            <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">                <span class="comment">/// 进入loop时参数说处理完事件就返回。</span></span><br><span class="line">                retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">                <span class="comment">/// 超出传入参数标记的超时时间了</span></span><br><span class="line">                retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">                <span class="comment">/// 被外部调用者强制停止了</span></span><br><span class="line">                retVal = kCFRunLoopRunStopped;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">                <span class="comment">/// source/timer/observer一个都没有了</span></span><br><span class="line">                retVal = kCFRunLoopRunFinished;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (retVal == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// 10. 通知 Observers: RunLoop 即将退出。</span></span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p>
<h2 id="RunLoop-的底层实现"><a href="#RunLoop-的底层实现" class="headerlink" title="RunLoop 的底层实现"></a>RunLoop 的底层实现</h2><p>从上面代码可以看到，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()。为了解释这个逻辑，下面稍微介绍一下 OSX&#x2F;iOS 的系统架构。</p>
<p><a href="/img/understandingRunloop/RunLoop_3.png"><img src = "/img/understandingRunloop/RunLoop_3.png" width = 307 height = 193 alt = "RunLoop_3.png" /></a></p>
<p>苹果官方将整个系统大致划分为上述4个层次：<br>应用层包括用户能接触到的图形应用，例如 Spotlight、Aqua、SpringBoard 等。<br>应用框架层即开发人员接触到的 Cocoa 等框架。<br>核心框架层包括各种核心框架、OpenGL 等内容。<br>Darwin 即操作系统的核心，包括系统内核、驱动、Shell 等内容，这一层是开源的，其所有源码都可以在 <a target="_blank" rel="noopener" href="http://opensource.apple.com/">http://opensource.apple.com</a> 里找到。</p>
<p>我们在深入看一下 Darwin 这个核心的架构：</p>
<p><a href="/img/understandingRunloop/RunLoop_4.png"><img src = "/img/understandingRunloop/RunLoop_4.png" width = 358 height = 317 alt = "RunLoop_4.png" /></a></p>
<p>其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit (还包括一些上面没标注的内容)，共同组成了 XNU 内核。<br>XNU 内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC (进程间通信)等非常少量的基础服务。<br>BSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。<br>IOKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。</p>
<p>Mach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为”对象”。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。</p>
<p>Mach 的消息定义是在 &lt;mach&#x2F;message.h&gt; 头文件的，很简单：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  mach_msg_header_t header;</span><br><span class="line">  mach_msg_body_t body;</span><br><span class="line">&#125; mach_msg_base_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  mach_msg_bits_t msgh_bits;</span><br><span class="line">  mach_msg_size_t msgh_size;</span><br><span class="line">  mach_port_t msgh_remote_port;</span><br><span class="line">  mach_port_t msgh_local_port;</span><br><span class="line">  mach_port_name_t msgh_voucher_port;</span><br><span class="line">  mach_msg_id_t msgh_id;</span><br><span class="line">&#125; mach_msg_header_t;</span><br></pre></td></tr></table></figure>

<p>一条 Mach 消息实际上就是一个二进制数据包 (BLOB)，其头部定义了当前端口 local_port 和目标端口 remote_port，<br>发送和接受消息是通过同一个 API 进行的，其 option 标记了消息传递的方向：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mach_msg_return_t mach_msg(</span><br><span class="line">			mach_msg_header_t *msg,</span><br><span class="line">			mach_msg_option_t option,</span><br><span class="line">			mach_msg_size_t send_size,</span><br><span class="line">			mach_msg_size_t rcv_size,</span><br><span class="line">			mach_port_name_t rcv_name,</span><br><span class="line">			mach_msg_timeout_t timeout,</span><br><span class="line">			mach_port_name_t notify);</span><br></pre></td></tr></table></figure>

<p>为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图：</p>
<p><a href="/img/understandingRunloop/RunLoop_5.png"><img src = "/img/understandingRunloop/RunLoop_5.png" width = 393 height = 271 alt = "RunLoop_5.png" /></a></p>
<p>这些概念可以参考维基百科: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/System_call">System_call</a>、<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Trap_(computing)">Trap_(computing)</a>。</p>
<p>RunLoop 的核心就是一个 mach_msg() (见上面代码的第7步)，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。</p>
<p>关于具体的如何利用 mach port 发送信息，可以看看 <a target="_blank" rel="noopener" href="http://nshipster.com/inter-process-communication/">NSHipster 这一篇文章</a>，或者<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000002400329">这里</a>的中文翻译 。</p>
<p>关于Mach的历史可以看看这篇很有趣的文章：<a target="_blank" rel="noopener" href="http://history.programmer.com.cn/8121/">Mac OS X 背后的故事（三）Mach 之父 Avie Tevanian</a>。</p>
<h2 id="苹果用-RunLoop-实现的功能"><a href="#苹果用-RunLoop-实现的功能" class="headerlink" title="苹果用 RunLoop 实现的功能"></a>苹果用 RunLoop 实现的功能</h2><p>首先我们可以看一下 App 启动后 RunLoop 的状态：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoop</span> &#123;</span><br><span class="line">    current mode = kCFRunLoopDefaultMode</span><br><span class="line">    common modes = &#123;</span><br><span class="line">        <span class="built_in">UITrackingRunLoopMode</span></span><br><span class="line">        kCFRunLoopDefaultMode</span><br><span class="line">    &#125;</span><br><span class="line">    common mode items = &#123;</span><br><span class="line">        <span class="comment">// source0 (manual)</span></span><br><span class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order =<span class="number">-1</span>, &#123;</span><br><span class="line">            callout = _UIApplicationHandleEventQueue&#125;&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order =<span class="number">-1</span>, &#123;</span><br><span class="line">            callout = PurpleEventSignalCallback &#125;&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>, &#123;</span><br><span class="line">            callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line">        <span class="comment">// source1 (mach port)</span></span><br><span class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">17923</span>&#125;&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">12039</span>&#125;&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">16647</span>&#125;&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order =<span class="number">-1</span>, &#123;</span><br><span class="line">            callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>, &#123;port = <span class="number">2407</span>,</span><br><span class="line">            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>, &#123;port = <span class="number">1</span>c03,</span><br><span class="line">            callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>, &#123;port = <span class="number">1</span>b03,</span><br><span class="line">            callout = __IOHIDEventSystemClientQueueCallback&#125;&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">1</span>, &#123;port = <span class="number">1903</span>,</span><br><span class="line">            callout = __IOMIGMachPortPortCallback&#125;&#125;</span><br><span class="line">        <span class="comment">// Ovserver</span></span><br><span class="line">        <span class="built_in">CFRunLoopObserver</span> &#123;order = <span class="number">-2147483647</span>, activities = <span class="number">0x1</span>, <span class="comment">// Entry</span></span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopObserver</span> &#123;order = <span class="number">0</span>, activities = <span class="number">0x20</span>,          <span class="comment">// BeforeWaiting</span></span><br><span class="line">            callout = _UIGestureRecognizerUpdateObserver&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopObserver</span> &#123;order = <span class="number">1999000</span>, activities = <span class="number">0xa0</span>,    <span class="comment">// BeforeWaiting | Exit</span></span><br><span class="line">            callout = _afterCACommitHandler&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopObserver</span> &#123;order = <span class="number">2000000</span>, activities = <span class="number">0xa0</span>,    <span class="comment">// BeforeWaiting | Exit</span></span><br><span class="line">            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopObserver</span> &#123;order = <span class="number">2147483647</span>, activities = <span class="number">0xa0</span>, <span class="comment">// BeforeWaiting | Exit</span></span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">        <span class="comment">// Timer</span></span><br><span class="line">        <span class="built_in">CFRunLoopTimer</span> &#123;firing = No, interval = <span class="number">3.1536e+09</span>, tolerance = <span class="number">0</span>,</span><br><span class="line">            next fire date = <span class="number">453098071</span> (<span class="number">-4421.76019</span> @ <span class="number">96223387169499</span>),</span><br><span class="line">            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    modes ＝ &#123;</span><br><span class="line">        <span class="built_in">CFRunLoopMode</span>  &#123;</span><br><span class="line">            sources0 =  &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">            sources1 =  &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">            observers = &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">            timers =    &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="built_in">CFRunLoopMode</span>  &#123;</span><br><span class="line">            sources0 =  &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">            sources1 =  &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">            observers = &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">            timers =    &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="built_in">CFRunLoopMode</span>  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>, &#123;</span><br><span class="line">                    callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = &#123;</span><br><span class="line">                <span class="built_in">CFRunLoopObserver</span> &gt;&#123;activities = <span class="number">0xa0</span>, order = <span class="number">2000000</span>,</span><br><span class="line">                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">            )&#125;,</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="built_in">CFRunLoopMode</span>  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">-1</span>, &#123;</span><br><span class="line">                    callout = PurpleEventSignalCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = &#123;</span><br><span class="line">                <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">-1</span>, &#123;</span><br><span class="line">                    callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="built_in">CFRunLoopMode</span>  &#123;</span><br><span class="line">            sources0 = (null),</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>可以看到，系统默认注册了5个Mode:</p>
<ol>
<li>kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</li>
<li>UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</li>
<li>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。</li>
<li>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。</li>
<li>kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。</li>
</ol>
<p>你可以在<a target="_blank" rel="noopener" href="http://iphonedevwiki.net/index.php/CFRunLoop">这里</a>看到更多的苹果内部的 Mode，但那些 Mode 在开发中就很难遇到了。</p>
<p>当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去 (call out), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// 1. 通知Observers，即将进入RunLoop</span></span><br><span class="line">    <span class="comment">/// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();</span></span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">/// 2. 通知 Observers: 即将触发 Timer 回调。</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);</span><br><span class="line">        <span class="comment">/// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class="line">        <span class="comment">/// 4. 触发 Source0 (非基于port的) 回调。</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class="line">        <span class="comment">/// 6. 通知Observers，即将进入休眠</span></span><br><span class="line">        <span class="comment">/// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);</span><br><span class="line">        <span class="comment">/// 7. sleep to wait msg.</span></span><br><span class="line">        mach_msg() -&gt; mach_msg_trap();</span><br><span class="line">        <span class="comment">/// 8. 通知Observers，线程被唤醒</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);</span><br><span class="line">        <span class="comment">/// 9. 如果是被Timer唤醒的，回调Timer</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);</span><br><span class="line">        <span class="comment">/// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span></span><br><span class="line">        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);</span><br><span class="line">        <span class="comment">/// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);</span><br><span class="line">    &#125; <span class="keyword">while</span> (...);</span><br><span class="line">    <span class="comment">/// 10. 通知Observers，即将退出RunLoop</span></span><br><span class="line">    <span class="comment">/// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();</span></span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h3><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p>
<p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p>
<p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p>
<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>
<h3 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p>
<p>当一个硬件事件(触摸&#x2F;锁屏&#x2F;摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考<a target="_blank" rel="noopener" href="http://iphonedevwiki.net/index.php/IOHIDFamily">这里</a>。SpringBoard 只接收按键(锁屏&#x2F;静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p>
<p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture&#x2F;处理屏幕旋转&#x2F;发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin&#x2F;Move&#x2F;End&#x2F;Cancel 事件都是在这个回调中完成的。</p>
<h3 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h3><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin&#x2F;Move&#x2F;End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>
<p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p>
<p>当有 UIGestureRecognizer 的变化(创建&#x2F;销毁&#x2F;状态改变)时，这个回调都会进行相应处理。</p>
<h3 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h3><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView&#x2F;CALayer 的层次时，或者手动调用了 UIView&#x2F;CALayer 的 setNeedsLayout&#x2F;setNeedsDisplay方法后，这个 UIView&#x2F;CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p>
<p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：<br>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView&#x2F;CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>
<p>这个函数内部的调用栈大概是这样的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</span><br><span class="line">    QuartzCore:CA::Transaction::observer_callback:</span><br><span class="line">        CA::Transaction::commit();</span><br><span class="line">            CA::Context::commit_transaction();</span><br><span class="line">                CA::Layer::layout_and_display_if_needed();</span><br><span class="line">                    CA::Layer::layout_if_needed();</span><br><span class="line">                        [<span class="built_in">CALayer</span> layoutSublayers];</span><br><span class="line">                            [<span class="built_in">UIView</span> layoutSubviews];</span><br><span class="line">                    CA::Layer::display_if_needed();</span><br><span class="line">                        [<span class="built_in">CALayer</span> display];</span><br><span class="line">                            [<span class="built_in">UIView</span> drawRect];</span><br></pre></td></tr></table></figure>


<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>
<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>
<p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。</p>
<h3 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h3><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>
<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>
<h3 id="关于GCD"><a href="#关于GCD" class="headerlink" title="关于GCD"></a>关于GCD</h3><p>实际上 RunLoop 底层也会用到 GCD 的东西，比如 RunLoop 是用 dispatch_source_t 实现的 Timer（评论中有人提醒，NSTimer 是用了 XNU 内核的 mk_timer，我也仔细调试了一下，发现 NSTimer 确实是由 mk_timer 驱动，而非 GCD 驱动的）。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。</p>
<p>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>
<h3 id="关于网络请求"><a href="#关于网络请求" class="headerlink" title="关于网络请求"></a>关于网络请求</h3><p>iOS 中，关于网络请求的接口自下至上有如下几层:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFSocket</span></span><br><span class="line"><span class="built_in">CFNetwork</span>       -&gt;ASIHttpRequest</span><br><span class="line"><span class="built_in">NSURLConnection</span> -&gt;AFNetworking</span><br><span class="line"><span class="built_in">NSURLSession</span>    -&gt;AFNetworking2, Alamofire</span><br></pre></td></tr></table></figure>

<ul>
<li>CFSocket 是最底层的接口，只负责 socket 通信。</li>
<li>CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。</li>
<li>NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。</li>
<li>NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。</li>
</ul>
<p>下面主要介绍下 NSURLConnection 的工作过程。</p>
<p>通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。</p>
<p>当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。</p>
<p><a href="/img/understandingRunloop/RunLoop_network.png"><img src = "/img/understandingRunloop/RunLoop_network.png" width = 677 height = 471 alt = "RunLoop_network.png" /></a></p>
<p>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。</p>
<h2 id="RunLoop-的实际应用举例"><a href="#RunLoop-的实际应用举例" class="headerlink" title="RunLoop 的实际应用举例"></a>RunLoop 的实际应用举例</h2><h3 id="AFNetworking"><a href="#AFNetworking" class="headerlink" title="AFNetworking"></a>AFNetworking</h3><p><a target="_blank" rel="noopener" href="https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking%2FAFURLConnectionOperation.m">AFURLConnectionOperation</a> 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">void</span>)networkRequestThreadEntryPoint:(<span class="type">id</span>)__unused object &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [[<span class="built_in">NSThread</span> currentThread] setName:<span class="string">@&quot;AFNetworking&quot;</span>];</span><br><span class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="built_in">NSThread</span> *)networkRequestThread &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSThread</span> *_networkRequestThread = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> </span><br><span class="line">        selector:<span class="keyword">@selector</span>(networkRequestThreadEntryPoint:) object:<span class="literal">nil</span>];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _networkRequestThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RunLoop 启动前内部必须要有至少一个 Timer&#x2F;Observer&#x2F;Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)start &#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isCancelled]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(cancelConnection) </span><br><span class="line">       		     onThread:[[<span class="keyword">self</span> <span class="keyword">class</span>] networkRequestThread] </span><br><span class="line">       		   withObject:<span class="literal">nil</span> </span><br><span class="line">       		waitUntilDone:<span class="literal">NO</span> </span><br><span class="line">       		        modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span> isReady]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.state = AFOperationExecutingState;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(operationDidStart)</span><br><span class="line">         	     onThread:[[<span class="keyword">self</span> <span class="keyword">class</span>] networkRequestThread] </span><br><span class="line">           	   withObject:<span class="literal">nil</span> </span><br><span class="line">        	waitUntilDone:<span class="literal">NO</span> </span><br><span class="line">        		modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。</p>
<h3 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h3><p><a target="_blank" rel="noopener" href="https://github.com/facebook/AsyncDisplayKit">AsyncDisplayKit</a> 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下：</p>
<p>UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。</p>
<p>排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。<br>绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。<br>UI对象操作通常包括 UIView&#x2F;CALayer 等 UI 对象的创建、设置属性和销毁。</p>
<p>其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。</p>
<p>为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView&#x2F;CALayer，它具有和 UIView&#x2F;CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView&#x2F;CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView&#x2F;CALayer 去。</p>
<p>ASDK 仿照 QuartzCore&#x2F;UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。<br>具体的代码可以看这里：<a target="_blank" rel="noopener" href="https://github.com/facebook/AsyncDisplayKit/blob/master/AsyncDisplayKit%2FDetails%2FTransactions%2F_ASAsyncTransactionGroup.m">_ASAsyncTransactionGroup</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/09/06/mobileTerminalImageFormat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qxy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一艘小船">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/09/06/mobileTerminalImageFormat/" class="post-title-link" itemprop="url">移动端图片格式调研</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-09-06 09:21:00" itemprop="dateCreated datePublished" datetime="2016-09-06T09:21:00+08:00">2016-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转载自<a target="_blank" rel="noopener" href="http://blog.ibireme.com/2015/11/02/mobile_image_benchmark/">YY大神</a></p>
<p>图片通常是移动端流量耗费最多的部分，并且占据着重要的视觉空间。合理的图片格式选用和优化可以为你节省带宽、提升视觉效果。在这篇文章里我会分析一下目前主流和新兴的几种图片格式的特点、性能分析、参数调优，以及相关开源库的选择。</p>
<h2 id="几种图片格式的简介"><a href="#几种图片格式的简介" class="headerlink" title="几种图片格式的简介"></a>几种图片格式的简介</h2><p><font color=#a2c700> JPEG </font>  是目前最常见的图片格式，它诞生于 1992 年，是一个很古老的格式。它只支持有损压缩，其压缩算法可以精确控制压缩比，以图像质量换得存储空间。由于它太过常见，以至于许多移动设备的 CPU 都支持针对它的硬编码与硬解码。

<p><font color=#a2c700> PNG </font>  诞生在 1995 年，比 JPEG 晚几年。它本身的设计目的是替代 GIF 格式，所以它与 GIF 有更多相似的地方。PNG 只支持无损压缩，所以它的压缩比是有上限的。相对于 JPEG 和 GIF 来说，它最大的优势在于支持完整的透明通道。</p>
<p><font color=#a2c700> GIF </font>  诞生于 1987 年，随着初代互联网流行开来。它有很多缺点，比如通常情况下只支持 256 种颜色、透明通道只有 1 bit、文件压缩比不高。它唯一的优势就是支持多帧动画，凭借这个特性，它得以从 Windows 1.0 时代流行至今，而且仍然大受欢迎。</p>
<p>在上面这些图片格式诞生后，也有不少公司或团体尝试对他们进行改进，或者创造其他更加优秀的图片格式，比如 JPEG 小组的 JPEG 2000、微软的 JPEG-XR、Google 的 WebP、个人开发者发布的 BPG、FLIF 等。它们相对于老牌的那几个图片格式来说有了很大的进步，但出于各种各样的原因，只有少数几个格式能够流行开来。下面三种就是目前实力比较强的新兴格式了：</p>
<p><font color=#a2c700> APNG </font>  是 Mozilla 在 2008 年发布的一种图片格式，旨在替换掉画质低劣的 GIF 动画。它实际上只是相当于 PNG 格式的一个扩展，所以 Mozilla 一直想把它合并到 PNG 标准里面去。然而 PNG 开发组并没有接受 APNG 这个扩展，而是一直在推进它自己的 MNG 动图格式。MNG 格式过于复杂以至于并没有什么系统或浏览器支持，而 APNG 格式由于简单容易实现，目前已经渐渐流行开来。Mozilla 自己的 Firefox 首先支持了 APNG，随后苹果的 Safari 也开始有了支持， Chrome 目前也<a target="_blank" rel="noopener" href="https://codereview.chromium.org/1250373006/">已经尝试</a>开始支持 ，可以说未来前景很好。</p>
<p><font color=#a2c700> WebP </font>  是 Google 在 2010 年发布的图片格式，希望以更高的压缩比替代 JPEG。它用 VP8 视频帧内编码作为其算法基础，取得了不错的压缩效果。它支持有损和无损压缩、支持完整的透明通道、也支持多帧动画，并且没有版权问题，是一种非常理想的图片格式。借由 Google 在网络世界的影响力，WebP 在几年的时间内已经得到了广泛的应用。看看你手机里的 App：微博、微信、QQ、淘宝、网易新闻等等，每个 App 里都有 WebP 的身影。Facebook 则更进一步，用 WebP 来显示聊天界面的贴纸动画。</p>
<p><font color=#a2c700> BPG </font>  是著名程序员 Fabrice Bellard 在去年 (2014年) 发布的一款超高压缩比的图片格式。这个程序员有些人可能感觉面生，但说起他的作品 FFmpeg、QEMU 大家想必是都知道的。BPG 使用 HEVC (即 H.265) 帧内编码作为其算法基础，就这点而言，它毋庸置疑是当下最为先进的图片压缩格式。相对于 JP2、JPEG-XR、WebP 来说，同等体积下 BPG 能提供更高的图像质量。另外，得益于它本身基于视频编码算法的特性，它能以非常小的文件体积保存多帧动画。 Fabrice Bellard 聪明的地方在于，他知道自己一个人无法得到各大浏览器厂商的支持，所以他还特地开发了 Javascript 版的解码器，任何浏览器只要加载了这个 76KB 大小的 JS 文件，就可以直接显示 BPG 格式的图片了。目前阻碍它流行的原因就是 HEVC 的版权问题和它较长的编码解码时间。尽管这个图片格式才刚刚发布一年，但已经有不少厂子开始试用了，比如<a target="_blank" rel="noopener" href="http://www.infoq.com/cn/news/2015/08/onesdk-shoutao">阿里</a>和<a target="_blank" rel="noopener" href="http://www.infoq.com/cn/articles/how-subject-test-works">腾讯</a>。</p> </p>
<h2 id="移动端图片类型的支持情况"><a href="#移动端图片类型的支持情况" class="headerlink" title="移动端图片类型的支持情况"></a>移动端图片类型的支持情况</h2><p>目前主流的移动端对图片格式的支持情况如何呢？我们分别来看一下 Android 和 iOS 目前的图片编解码架构吧：</p>
<p><a href = "/img/mobileTerminalImageFormat/mobile_image_arch.png"><img src = "/img/mobileTerminalImageFormat/mobile_image_arch.png" width = 635 height = 279 alt = "mobile_image_arch" /></a></p>
<p>Android 的图片编码解码是由 Skia 图形库负责的，Skia 通过挂接第三方开源库实现了常见的图片格式的编解码支持。目前来说，Android 原生支持的格式只有 JPEG、PNG、GIF、BMP 和 WebP (Android 4.0 加入)，在上层能直接调用的编码方式也只有 JPEG、PNG、WebP 这三种。目前来说 Android 还不支持直接的动图编解码。</p>
<p>iOS 底层是用 ImageIO.framework 实现的图片编解码。目前 iOS 原生支持的格式有：JPEG、JPEG2000、PNG、GIF、BMP、ICO、TIFF、PICT，自 iOS 8.0 起，ImageIO 又加入了 APNG、SVG、RAW 格式的支持。在上层，开发者可以直接调用 ImageIO 对上面这些图片格式进行编码和解码。对于动图来说，开发者可以解码动画 GIF 和 APNG、可以编码动画 GIF。</p>
<p>两个平台在导入第三方编解码库时，都多少对他们进行了一些修改，比如 Android 对 libjpeg 等进行的调整以更好的控制内存，iOS 对 libpng 进行了修改以支持 APNG，并增加了多线程编解码的特性。除此之外，iOS 专门针对 JPEG 的编解码开发了 AppleJPEG.framework，实现了性能更高的硬编码和硬解码，只有当硬编码解码失败时，libjpeg 才会被用到。</p>
<h2 id="静态图片的编码与解码"><a href="#静态图片的编码与解码" class="headerlink" title="静态图片的编码与解码"></a>静态图片的编码与解码</h2><p>由于我目前主要是做 iOS 开发，所以下面的性能评测都是基于 iPhone 的，主要测试代码可以在这里看到。测试素材很少，只有两个：</p>
<p><a href = "/img/mobileTerminalImageFormat/dribbble512_pngcrush.png"><img src = "/img/mobileTerminalImageFormat/dribbble512_pngcrush.png" width = 256 height = 256 alt = "dribbble512_pngcrush.png" /></a><a href = "/img/mobileTerminalImageFormat/lena512_weibo.jpg"><img src = "/img/mobileTerminalImageFormat/lena512_weibo.jpg" width = 256 height = 256 alt = "lena512_weibo.jpg" /></a></p>
<p>第一张是Dribbble 的 Logo，包含 Alpha 通道，用于测试简单的、图形类的图像。<br>第二张经典的 Lena 图，用于测试照片类的、具有丰富细节的图像。<br>每个图像都有 64x64、128x128、256x256、512x512 四种分辨率。<br>测试素材过少可能导致某些测试不够准确，但作为参考大致是没问题的。</p>
<h4 id="JPEG"><a href="#JPEG" class="headerlink" title=" JPEG "></a><font color=#0088000> JPEG </font></h4><p>目前比较知名的 JPEG 库有以下三个：</p>
<p>   <a target="_blank" rel="noopener" href="http://libjpeg.sourceforge.net/">libjpeg</a>：开发时间最早，使用最广泛的 JPEG 库。由于 JPEG 标准过于复杂和模糊，并没有其他人去实现，所以这个库是 JPEG 的事实标准。</p>
<p>   <a target="_blank" rel="noopener" href="http://libjpeg-turbo.virtualgl.org/">libjpeg-turbo</a>：一个致力于提升编解码速度的 JPEG 库。它基于 libjpeg 进行了改造，用 SIMD 指令集 (MMX、SSE2、NEON) 重写了部分代码，官网称相对于 libjpeg 有 2 到 4 倍的性能提升。</p>
<p>   <a target="_blank" rel="noopener" href="http://mozjpeg.codelove.de/">MozJPEG</a>： 一个致力于提升压缩比的 JPEG 库。它是 Mozilla 在 2014 年发布的基于 libjpeg-turbo 进行改造的库，相对于 libjpeg 有 5% ~ 15%  的压缩比提升，但相应的其编码速度也慢了很多。</p>
<p>除了上面这三个库，苹果自己也开发了一个 AppleJPEG，但并没有开源。其调用了芯片提供的 DSP 硬编码和硬解码的功能。虽然它不如上面这三个库功能完善，但其性能非常高。在我的测试中，其编解码速度通常是 libjpeg-turbo 的 1~2 倍。可惜的是，目前开发者并不能直接访问这个库。</p>
<p>下面是 ImageIO (AppleJPEG&#x2F;libpng) 在 iPhone 6 上的编解码性能：</p>
<p><a href = "/img/mobileTerminalImageFormat/jpeg_bench_dribbble.png"><img src = "/img/mobileTerminalImageFormat/jpeg_bench_dribbble.png" width = 676 height = 242 alt = "jpeg_bench_dribbble.png" /></a><a href = "/img/mobileTerminalImageFormat/jpeg_bench_lena.png"><img src = "/img/mobileTerminalImageFormat/jpeg_bench_lena.png" width = 676 height = 242 alt = "jpeg_bench_lena.png" /></a></p>
<p>可以看到，JPEG 编码中 quality 越小，图片体积就越小，质量越也差，编码时间也越短。解码时间并没有很大的差距，可能是其大部分时间消耗在了函数调用、硬件调用上。苹果在自己的相册 Demo 中提供的 quality 的默认值是 0.9，在这个值附近，图像质量和体积、编码解码时间之间都能取得不错的平衡。</p>
<h4 id="PNG"><a href="#PNG" class="headerlink" title=" PNG "></a><font color=#0088000> PNG </font></h4><p>相对于 JPEG 来说，PNG 标准更为清晰和简单，因此有很多公司或个人都有自己的 PNG 编码解码实现。但目前使用最广的还是 PNG 官方发布的 <a target="_blank" rel="noopener" href="http://www.libpng.org/pub/png/libpng.html">libpng</a> 库。iOS 和 Android 底层都是调用这个库实现的 PNG 编解码。</p>
<p>下面是 PNG 在 iPhone 6 上的编解码性能：</p>
<p><a href = "/img/mobileTerminalImageFormat/jpeg_png_bench.png"><img src = "/img/mobileTerminalImageFormat/jpeg_png_bench.png" width = 676 height = 260 alt = "jpeg_png_bench.png" /></a></p>
<p>可以看到，在编解码图形类型（颜色少、细节少）的图片时，PNG 和 JPEG 差距并不大；但是对于照片类型（颜色和细节丰富）的图片来说，PNG 在文件体积、编解码速度上都差 JPEG 不少了。</p>
<p>和 JPEG 不同，PNG 是无损压缩，其并不能提供压缩比的选项，其压缩比是有上限的。目前网上有很多针对 PNG 进行优化的工具和服务，旨在提升 PNG 的压缩比。下面是常见的几个 PNG 压缩工具的性能对比：</p>
<p><a href = "/img/mobileTerminalImageFormat/png_tools_bench.png"><img src = "/img/mobileTerminalImageFormat/png_tools_bench.png" width = 592 height = 306 alt = "png_tools_bench.png" /></a></p>
<p><a target="_blank" rel="noopener" href="http://pmt.sourceforge.net/pngcrush/">pngcrush</a> 是 Xcode 自带的 PNG 压缩工具，相对于设计师用 Photoshop 生成的图片来说，它能取得不错的压缩效果。<a target="_blank" rel="noopener" href="https://imageoptim.com/">ImageOptim</a> 则更进一步，对每张图用多种缩算法进行比对，选择压缩比更高的结果，进一步缩小了文件体积。<a target="_blank" rel="noopener" href="https://tinypng.com/">TinyPNG.com</a> 相对于其他工具来说，压缩比高得不像话。它启用了类似 GIF 那样的颜色索引表对 PNG 进行压缩，所以会导致颜色丰富的图片丢失掉一部分细节。如果使用 TinyPNG 的话，最好在压缩完成后让设计师看一下颜色效果是否可以接受。</p>
<h4 id="WebP"><a href="#WebP" class="headerlink" title=" WebP "></a><font color=#0088000> WebP </font></h4><p>WebP 标准是 Google 定制的，迄今为止也只有 Google 发布的 <a target="_blank" rel="noopener" href="https://developers.google.com/speed/webp/">libwebp</a> 实现了该的编解码 。 所以这个库也是该格式的事实标准。</p>
<h5 id="WebP-编码主要有几个参数："><a href="#WebP-编码主要有几个参数：" class="headerlink" title="WebP 编码主要有几个参数："></a>WebP 编码主要有几个参数：</h5>   <p><font color=orange>lossless</font>: YES:有损编码 NO:无损编码。WebP 主要优势在于有损编码，其无损编码的性能和压缩比表现一般。

<p>   <font color=orange>quality</font>: [0~100] 图像质量，0表示最差质量，文件体积最小，细节损失严重，100表示最高图像质量，文件体积较大。该参数只针对有损压缩有明显效果。Google 官方的建议是 75，腾讯在对 WebP 评测时给出的建议也是 75。在这个值附近，WebP 能在压缩比、图像质量上取得较好的平衡。</p>
<p>   <font color=orange>method</font>: [0~6] 压缩比，0表示快速压缩，耗时短，压缩质量一般，6表示极限压缩，耗时长，压缩质量好。该参数也只针对有损压缩有明显效果。调节该参数最高能带来 20% ～ 40% 的更高压缩比，但相应的编码时间会增加 5～20 倍。Google 推荐的值是 4。</p>
<p>对于编码无损图片来说，quality&#x3D;0, method&#x3D;0<del>3 是相对来说比较合适的参数，能够节省编码时间，同时也有不错的压缩比。无损编码图片，quality&#x3D;75, method&#x3D;2</del>4 是比较合适的参数，能在编码时间、图片质量、文件体积之间有着不错的平衡。</p></p>
<h5 id="WebP-解码有三个参数："><a href="#WebP-解码有三个参数：" class="headerlink" title="WebP 解码有三个参数："></a>WebP 解码有三个参数：</h5>   <p><font color=orange> use_threads </font>: 是否启用 pthread 多线程解码。该参数只对宽度大于 512 的有损图片起作用。开启后内部会用多线程解码，CPU 占用会更高，解码时间平均能缩短 10%～20%。</p>

   <p><font color=orange> bypass_filtering </font>: 是否禁用滤波。该参数只对有损图片起作用，开启后大约能缩短 5%～10% 的解码时间，但会造成一些颜色过渡平滑的区域产生色带（banding）。</p>

   <p><font color=orange> no_fancy_upsampling </font>: 是否禁用上采样。该参数只对有损图片起作用。在我的测试中，开启该参数后，解码时间反而会增加 5～25%，同时会造成一些图像细节的丢失，线条边缘会增加杂色，显得不自然。</p>

<p>通常情况下，这三个参数都设为 NO 即可，如果要追求更高的解码速度，则可以尝试开启 use_threads 和 bypass_filtering 这两个参数。而 no_fancy_upsampling 在任何情况下都没必要开启。</p>
<p>由于 WebP 测试数据较多，这里只贴一下 512x512 大小的一部分测试结果，感兴趣的可以看文章结尾处的 Excel 附件。</p>
<p><a href = "/img/mobileTerminalImageFormat/webp_bench.png"><img src = "/img/mobileTerminalImageFormat/webp_bench.png" width = 734 height = 497 alt = "webp_bench.png" /></a></p>
<p>对于简单的图形类型的图像（比如 App 内的各种 UI 素材），WebP 无损压缩的文件体积和解码速度某些情况下已经比 PNG 还要理想了，如果你想要对 App 安装包体积进行优化，可以尝试一下 WebP。</p>
<p>对于复杂的图像（比如照片）来说，WebP 无损编码表现并不好，但有损编码表现却非常棒。相近质量的图片解码速度 WebP 相距 JPEG 也已经相差不大了，而文件压缩比却能提升不少。</p>
<h4 id="BPG"><a href="#BPG" class="headerlink" title=" BPG "></a><font color=#0088000> BPG </font></h4><p>BPG 是目前已知最优秀的有损压缩格式了，它能在相同质量下比 JPEG 减少 50% 的体积。下面是经典的 Lena 图的对比，你也可以在<a target="_blank" rel="noopener" href="http://xooyoozoo.github.io/yolo-octo-bugfixes/#cologne-cathedral&webp=s&bpg=s">这里</a>看到大量其他图片的 BPG、JPEG、JPEG2000、JPEG-XR、WebP 压缩效果的在线对比，效果非常明显。</p>
<p><a href = "/img/mobileTerminalImageFormat/bpg_demo.png"><img src = "/img/mobileTerminalImageFormat/bpg_demo.png" width = 520 height = 540 alt = "bpg_demo.png" /></a></p>
<p>BPG 目前只有作者发布的 <a target="_blank" rel="noopener" href="http://bellard.org/bpg/">libbpg</a> 可用。但作者基于 libbpg 编译出了一个 Javascript 解码器，很大的扩展了可用范围。bpg 可以以无损和有损压缩两种方式进行编码，有损压缩时可以用 quality 参数控制压缩比，可选范围为 0～51，数值越大压缩比越高。通常来说，25 附近是一个不错的选择，BPG 官方工具默认值是 28。</p>
<p>libbpg 目前并没有针对 ARM NEON 做优化，所以其在移动端的性能表现一般。下面是 iPhone 6 上的性能测试：</p>
<p><a href = "/img/mobileTerminalImageFormat/bpg_bench.png"><img src = "/img/mobileTerminalImageFormat/bpg_bench.png" width = 520 height = 520 alt = "bpg_bench.png" /></a></p>
<p>由于 bpg 编码时间太长，我并没有将数据放到表格里。可以看到相同质量下，BPG 的解码速度还是差 JPEG 太多，大约慢了 3～5 倍。目前来说，BPG 适用于那些对流量非常敏感，但对解码时间不敏感的地方。从网上的新闻来看，手机淘宝和手机QQ都已经有所尝试，但不清楚他们是否对 BPG 解码进行了优化。</p>
<h2 id="动态图片的编码与解码"><a href="#动态图片的编码与解码" class="headerlink" title="动态图片的编码与解码"></a>动态图片的编码与解码</h2><p>动图在网络上非常受欢迎，它近似视频，但通常实现简单、文件体积小，应用范围非常广泛。动图的始祖是 GIF，它自 Windows 1.0 时代就在互联网上流行开来，直到今天仍然难以被其他格式取代。尽管它非常古老，但其所用的原理和今天几种新兴格式几乎一样。</p>
<p>下面是一张 GIF 格式的 QQ 大表情：</p>
<p><a href = "/img/mobileTerminalImageFormat/bench_gif_demo.gif"><img src = "/img/mobileTerminalImageFormat/bench_gif_demo.gif" width = 110 height = 110 alt = "bench_gif_demo.gif" /></a></p>
<p>这张表情由 6 幅静态图构成，每幅图片有一定的存活时间，连贯播放就形成了动画：</p>
<p><a href = "/img/mobileTerminalImageFormat/bench_gif_demo1.png"><img src = "/img/mobileTerminalImageFormat/bench_gif_demo1.png" width = 700 height = 110 alt = "bench_gif_demo1.png" /></a></p>
<p>这几张图中，大部分内容是相近的，为了压缩文件体积，通常动图格式都支持一些特殊的方式对相似图片进行裁剪，只保留前后帧不同的部分：</p>
<p><a href = "/img/mobileTerminalImageFormat/bench_gif_demo2.png"><img src = "/img/mobileTerminalImageFormat/bench_gif_demo2.png" width = 700 height = 110 alt = "bench_gif_demo2.png" /></a></p>
<p>在解码动图时，解码器通常采用所谓”画布模式”进行渲染。想象一下：播放的区域是一张画布，第一帧播放前先把画布清空，然后完整的绘制上第一帧图；播放第二帧时，不再清空画布，而是只把和第一帧不同的区域覆盖到画布上，就像油画的创作那样。</p>
<p>像这样的第一帧就被称为关键帧（即 I 帧，帧内编码帧），而后续的那些通过补偿计算得到的帧被称为预测编码帧（P帧）。一个压缩的比较好的动图内，通常只有少量的关键帧，而其余都是预测编码帧；一个较差的压缩工具制作的动图内，则基本都是关键帧。不同的动图压缩工具通常能得到不同的结果。</p>
<p>除此之外，动图格式通常有更为详细的参数控制每一帧的绘制过程，下面是 GIF&#x2F;APNG&#x2F;WebP 通用的几个参数：</p>
<p>Disposal Method (清除方式)<br>   Do Not Dispose：把当前帧增量绘制到画布上，不清空画布。<br>   Restore to Background：绘制当前帧之前，先把画布清空为默认背景色。<br>   Restore to Previous：绘制下一帧前，把先把画布恢复为当前帧的前一帧</p>
<p>Blend Mode (混合模式)<br>   Blend None: 绘制时，全部通道（包含Alpha通道）都会覆盖到画布，相当于绘制前先清空画布的指定区域。<br>   Blend over：绘制时，Alpha 通道会被合成到画布，即通常情况下两张图片重叠的效果。</p>
<p>上面这些技术，就是常见动图格式的基础了，下面分别介绍一下不同动图格式的特点。</p>
<h4 id="GIF"><a href="#GIF" class="headerlink" title=" GIF "></a><font color=#0088000> GIF </font></h4><p>GIF 缺陷非常明显：它通常只支持 256 色索引颜色，这导致它只能通过抖动、差值等方式模拟较多丰富的颜色；它的 Alpha 通道只有 1 bit，这意味着一个像素只能是完全透明或者完全不透明。</p>
<p><a href = "/img/mobileTerminalImageFormat/gif_apng_demo.gif"><img src = "/img/mobileTerminalImageFormat/gif_apng_demo.gif" width = 220 height = 134 alt = "gif_apng_demo.gif" /></a></p>
<p>上面这是腾讯博客里的一张演示图，可以看到 GIF 由于 Alpha 通道的问题，产生了严重的”毛边”现象。目前通常的解决方案是在图片的边缘加一圈白边，以减轻这种视觉效果：</p>
<p><a href = "/img/mobileTerminalImageFormat/gif_wrong_demo.png"><img src = "/img/mobileTerminalImageFormat/gif_wrong_demo.png" width = 200 height = 129 alt = "gif_wrong_demo.png" /></a></p>
<p>可以仔细观察一下 QQ、微信等 App 里面的动画表情，几乎每个表情都被一圈白边所环绕，不得不说是一种很无奈的解决方案。</p>
<p>GIF 的制作工具有很多，但效果好、压缩比高的工具非常少。对于已经制作好的 GIF 来说，用 <a target="_blank" rel="noopener" href="http://www.imagemagick.org/script/index.php">imagemagick</a> 处理一下可以把文件体积压缩不少。如果需要将视频转为 GIF，<a target="_blank" rel="noopener" href="https://flixel.com/products/mac/cinemagraph-pro/">Cinemagraph Pro</a> 是个不错的傻瓜化工具。这里有一篇文章介绍如何用 <a target="_blank" rel="noopener" href="http://www.oschina.net/translate/high-quality-gif-with-ffmpeg">ffmpeg</a> 压缩 GIF，虽然参数调节有点麻烦，但效果非常理想。</p>
<p>下面是没有经过优化的 GIF 和经过 ffmpeg 优化编码的 GIF，可以看到差距非常大。</p>
<p><a href = "/img/mobileTerminalImageFormat/bbb-trans.gif"><img src = "/img/mobileTerminalImageFormat/bbb-trans.gif" width = 300 height = 169 alt = "bbb-trans.gif" /></a><a href = "/img/mobileTerminalImageFormat/bbb-nodither.gif"><img src = "/img/mobileTerminalImageFormat/bbb-nodither.gif" width = 300 height = 169 alt = "bbb-nodither.gif" /></a></p>
<h4 id="APNG"><a href="#APNG" class="headerlink" title=" APNG "></a><font color=#0088000> APNG </font></h4><p>APNG 目前并没有被 PNG 官方所接受，所以 libpng 并不能直接解码 APNG。但由于 APNG 只是基于 PNG 的一个简单扩展，所以在已经支持 PNG 的平台上，可以很轻松的用少量代码实现 APNG 的编解码。Chromium 为了支持 APNG 播放，只增加了<a target="_blank" rel="noopener" href="https://codereview.chromium.org/1312843006/">不到 600 行代码</a> ，我自己也用<a target="_blank" rel="noopener" href="https://github.com/ibireme/YYWebImage/blob/master/YYWebImage/Image/YYImageCoder.m#L149-L628">大概 500 行 C 代码</a>实现了一个简单的 APNG 编解码工具。另外，在支持 canvas 的浏览器上，可以用 <a target="_blank" rel="noopener" href="https://github.com/davidmz/apng-canvas">apng-canvas</a> 直接显示 APNG 动画。APNG 压缩最好的工具目前是 <a target="_blank" rel="noopener" href="https://sourceforge.net/projects/apngasm/">apngasm</a>，大部分图形化工具比如腾讯的 <a target="_blank" rel="noopener" href="http://isparta.github.io/index.html">iSparta</a> 都是基于这个工具开发的。</p>
<p>就目前而言， APNG 是 GIF 最好的替代了：实现简单，可用范围广，压缩比不错，显示效果好。</p>
<h4 id="WebP-1"><a href="#WebP-1" class="headerlink" title=" WebP "></a><font color=#0088000> WebP </font></h4><p>WebP 在 2010 年 发布时并没有支持动图。2012 年 libwebp v0.2 的时候，Google 才开始尝试支持动画，但其实现有很多问题，性能也非常差，以至于 Chrome 团队一直都没有接受。直到 2013 年，libwebp v0.4 时，动画格式才稳定下来才被 Chrome 所接受。</p>
<p>WebP 动图实际上是把多个单帧 WebP 数据简单打包到一个文件内，而并不是由单帧 WebP 扩展而来，以至于动图格式并不能向上兼容静态图。如果要支持动图，首先在编译 libwebp 时需要加上 demux 模块，解码 WebP 时需要先用 WebPDemuxer 尝试拆包，之后再把拆出来的单帧用 WebPDecode 解码。为了方便编译，我写了个<a target="_blank" rel="noopener" href="https://github.com/ibireme/YYWebImage/blob/master/Vendor/WebP.sh">脚本</a>用于打包 iOS 的静态库，加入了 mux 和 demux 模块。</p>
<p>Google 提供了两个简单的命令行工具用于制作动图：gif2webp 能把 GIF 转换为 WebP， webpmux 能把多个 WebP 图片打包为动态图，并且有着很多参数可以调节。这两个工具对相近帧的压缩并不太理想，以至于有的情况下压缩比还不如 APNG，但除此以外也没有其他什么更好的工具可以用了。</p>
<h4 id="BPG-1"><a href="#BPG-1" class="headerlink" title=" BPG "></a><font color=#0088000> BPG </font></h4><p>BPG 本身是基于 HEVC (H.265) 视频编码的，其最开始设计时就考虑到了动图的实现。由于它充分利用了 HEVC 的高压缩比和视频编码的特性，其动图压缩比远超其他格式。<a target="_blank" rel="noopener" href="http://bellard.org/bpg/animation.html">这里</a>和<a target="_blank" rel="noopener" href="https://kippler.com/bpg/test.html">这里</a>有几张 BPG 动图示例，可以看到相同质量下 BPG 动图只有 APNG&#x2F;WebP&#x2F;GIF 几十分之一的大小。</p>
<p>我在<a target="_blank" rel="noopener" href="https://github.com/ibireme/YYWebImage/blob/master/Demo%2FYYWebImageDemo%2FYYBPGCoder.m#L188-L264">这里</a>写了个简单的利用 libbpg 解码动图的方法，如有需要可以参考下。</p>
<h5 id="动图性能对比"><a href="#动图性能对比" class="headerlink" title="动图性能对比"></a>动图性能对比</h5><p>我把下面这张 GIF 分别转为 WebP、APNG、BPG 动图，并在 iPhone 6 上对其所有帧进行解码。</p>
<p><a href = "/img/mobileTerminalImageFormat/gif_ermilio.gif"><img src = "/img/mobileTerminalImageFormat/gif_ermilio.gif" width = 360 height = 214 alt = "gif_ermilio.gif" /></a></p>
<p>评测结果如下：</p>
<p><a href = "/img/mobileTerminalImageFormat/anim_bench.png"><img src = "/img/mobileTerminalImageFormat/anim_bench.png" width = 497 height = 164 alt = "anim_bench.png" /></a></p>
<p>APNG 在文件体积上比 GIF 略有优势，解码时间相差不多。WebP 在体积和解码时间上都具有较大的优势。BPG 在体积上优势最大，但解码时间也最长。这么看来，APNG 和 WebP 都是不错的选择，而 BPG 还有待性能优化。</p>
<p>最后做一个小广告：如果你是 iOS 平台的开发者，可以试试我开发的 <a target="_blank" rel="noopener" href="https://github.com/ibireme/YYWebImage">YYWebImage</a>，它支持 APNG、WebP、GIF 动图的异步加载与播放、编码与解码，支持渐进式图像加载，可以替代 SDWebImage、PINRemoteImage、FLAnimatedImage 等开源库。</p>
<h2 id="评测数据"><a href="#评测数据" class="headerlink" title="评测数据"></a>评测数据</h2><p>上面提到的所有评测数据表格：<a href="/img/mobileTerminalImageFormat/image_benchmark.xlsx">image_benchmark.xlsx</a> 推荐用 Excel 打开查看。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/09/03/keepScreenFluent/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qxy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一艘小船">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/09/03/keepScreenFluent/" class="post-title-link" itemprop="url">iOS保持界面流畅的技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-09-03 11:43:00" itemprop="dateCreated datePublished" datetime="2016-09-03T11:43:00+08:00">2016-09-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转载自<a target="_blank" rel="noopener" href="http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">YY大神</a></p>
<h2 id="演示项目"><a href="#演示项目" class="headerlink" title="演示项目"></a>演示项目</h2><p>在开始技术讨论前，你可以先下载我写的 Demo 跑到真机上体验一下：<a target="_blank" rel="noopener" href="https://github.com/ibireme/YYKit">Demo</a>。 Demo 里包含一个微博的 Feed 列表、发布视图，还包含一个 Twitter 的 Feed 列表。为了公平起见，所有界面和交互我都从官方应用原封不动的抄了过来，数据也都是从官方应用抓取的。你也可以自己抓取数据替换掉 Demo 中的数据，方便进行对比。尽管官方应用背后的功能更多更为复杂，但不至于会带来太大的交互性能差异。</p>
<div style="display: flex">
    <a style="flex: 1" href="/img/keepScreenFluent/weibo1.png">
        <img src = "/img/keepScreenFluent/weibo1.png"  />
    </a>
    <a style="flex: 1" href="/img/keepScreenFluent/weibo2.png">
        <img src = "/img/keepScreenFluent/weibo2.png"  />
    </a>
    <a style="flex: 1" href="/img/keepScreenFluent/twitter1.png">
        <img src = "/img/keepScreenFluent/twitter1.png"  />
    </a>
</div>


<p>这个 Demo 最低可以运行在 iOS 6 上，所以你可以把它跑到老设备上体验一下。在我的测试中，即使在 iPhone 4S 或者 iPad 3 上，Demo 列表在快速滑动时仍然能保持 50~60 FPS 的流畅交互，而其他诸如微博、朋友圈等应用的列表视图在滑动时已经有很严重的卡顿了。</p>
<p>微博的 Demo 有大约四千行代码，Twitter 的只有两千行左右代码，第三方库只用到了 YYKit，文件数量比较少，方便查看。好了，下面是正文。</p>
<h2 id="屏幕显示图像的原理"><a href="#屏幕显示图像的原理" class="headerlink" title="屏幕显示图像的原理"></a>屏幕显示图像的原理</h2><p><a href="/img/keepScreenFluent/ios_screen_scan.png"><img src = "/img/keepScreenFluent/ios_screen_scan.png" width = 321 height = 239 alt = "ios_screen_scan" /></a></p>
<p>首先从过去的 CRT 显示器原理说起。CRT 的电子枪按照上面方式，从上到下一行行扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。为了把显示器的显示过程和系统的视频控制器进行同步，显示器（或者其他硬件）会用硬件时钟产生一系列的定时信号。当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 HSync；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization），简称 VSync。显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。尽管现在的设备大都是液晶显示屏了，但原理仍然没有变。</p>
<p><a href="/img/keepScreenFluent/ios_screen_display.png"><img src = "/img/keepScreenFluent/ios_screen_display.png" width = 546 height = 251 alt = "ios_screen_display" /></a></p>
<p>通常来说，计算机系统中 CPU、GPU、显示器是以上面这种方式协同工作的。CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。</p>
<p>在最简单的情况下，帧缓冲区只有一个，这时帧缓冲区的读取和刷新都都会有比较大的效率问题。为了解决效率问题，显示系统通常会引入两个缓冲区，即双缓冲机制。在这种情况下，GPU 会预先渲染好一帧放入一个缓冲区内，让视频控制器读取，当下一帧渲染好后，GPU 会直接把视频控制器的指针指向第二个缓冲器。如此一来效率会有很大的提升。</p>
<p>双缓冲虽然能解决效率问题，但会引入一个新的问题。当视频控制器还未读取完成时，即屏幕内容刚显示一半时，GPU 将新的一帧内容提交到帧缓冲区并把两个缓冲区进行交换后，视频控制器就会把新的一帧数据的下半段显示到屏幕上，造成画面撕裂现象，如下图：</p>
<p><a href="/img/keepScreenFluent/ios_vsync_off.jpg"><img src = "/img/keepScreenFluent/ios_vsync_off.jpg" width = 724 height = 427 alt = "ios_vsync_off" /></a></p>
<p>为了解决这个问题，GPU 通常有一个机制叫做垂直同步（简写也是 V-Sync），当开启垂直同步后，GPU 会等待显示器的 VSync 信号发出后，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，也会带来部分延迟。</p>
<p>那么目前主流的移动设备是什么情况呢？从网上查到的资料可以知道，iOS 设备会始终使用双缓存，并开启垂直同步。而安卓设备直到 4.1 版本，Google 才开始引入这种机制，目前安卓系统是三缓存+垂直同步。</p>
<h2 id="卡顿产生的原因和解决方案"><a href="#卡顿产生的原因和解决方案" class="headerlink" title="卡顿产生的原因和解决方案"></a>卡顿产生的原因和解决方案</h2><p><a href="/img/keepScreenFluent/ios_frame_drop.png"><img src = "/img/keepScreenFluent/ios_frame_drop.png" width = 712 height = 184 alt = "ios_frame_drop" /></a></p>
<p>在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。</p>
<p>从上面的图中可以看到，CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化。</p>
<h3 id="CPU-资源消耗原因和解决方案"><a href="#CPU-资源消耗原因和解决方案" class="headerlink" title="CPU 资源消耗原因和解决方案"></a>CPU 资源消耗原因和解决方案</h3><h4 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h4><p>对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗 CPU 资源。尽量用轻量的对象代替重量的对象，可以对性能有所优化。比如 CALayer 比 UIView 要轻量许多，那么不需要响应触摸事件的控件，用 CALayer 显示会更加合适。如果对象不涉及 UI 操作，则尽量放到后台线程去创建，但可惜的是包含有 CALayer 的控件，都只能在主线程创建和操作。通过 Storyboard 创建视图对象时，其资源消耗会比直接通过代码创建对象要大非常多，在性能敏感的界面里，Storyboard 并不是一个好的技术选择。</p>
<p>尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去。尽管这实现起来比较麻烦，并且带来的优势并不多，但如果有能力做，还是要尽量尝试一下。如果对象可以复用，并且复用的代价比释放、创建新对象要小，那么这类对象应当尽量放到一个缓存池里复用。</p>
<h4 id="对象调整"><a href="#对象调整" class="headerlink" title="对象调整"></a>对象调整</h4><p>对象的调整也经常是消耗 CPU 资源的地方。这里特别说一下 CALayer：CALayer 内部并没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 里，同时还会通知 delegate、创建动画等等，非常消耗资源。UIView 的关于显示相关的属性（比如 frame&#x2F;bounds&#x2F;transform）等实际上都是 CALayer 属性映射来的，所以对 UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性。对此你在应用中，应该尽量减少不必要的属性修改。</p>
<p>当视图层次调整时，UIView、CALayer 之间会出现很多方法调用与通知，所以在优化性能时，应该尽量避免调整视图层次、添加和移除视图。</p>
<h4 id="对象销毁"><a href="#对象销毁" class="headerlink" title="对象销毁"></a>对象销毁</h4><p>对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去。这里有个小 Tip：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *tmp = <span class="keyword">self</span>.array;</span><br><span class="line"><span class="keyword">self</span>.array = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">   [tmp <span class="keyword">class</span>];</span><br><span class="line">&#125;);	</span><br></pre></td></tr></table></figure>

<h4 id="布局计算"><a href="#布局计算" class="headerlink" title="布局计算"></a>布局计算</h4><p>视图布局的计算是 App 中最为常见的消耗 CPU 资源的地方。如果能在后台线程提前计算好视图布局、并且对视图布局进行缓存，那么这个地方基本就不会产生性能问题了。</p>
<p>不论通过何种技术对视图进行布局，其最终都会落到对 UIView.frame&#x2F;bounds&#x2F;center 等属性的调整上。上面也说过，对这些属性的调整非常消耗资源，所以尽量提前计算好布局，在需要时一次性调整好对应属性，而不要多次、频繁的计算和调整这些属性。</p>
<h4 id="Autolayout"><a href="#Autolayout" class="headerlink" title="Autolayout"></a>Autolayout</h4><p>Autolayout 是苹果本身提倡的技术，在大部分情况下也能很好的提升开发效率，但是 Autolayout 对于复杂视图来说常常会产生严重的性能问题。随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级上升。具体数据可以看这个文章：<a target="_blank" rel="noopener" href="http://pilky.me/36/">http://pilky.me/36/</a>。 如果你不想手动调整 frame 等属性，你可以用一些工具方法替代（比如常见的 left&#x2F;right&#x2F;top&#x2F;bottom&#x2F;width&#x2F;height 快捷属性），或者使用 ComponentKit、AsyncDisplayKit 等框架。</p>
<h4 id="文本计算"><a href="#文本计算" class="headerlink" title="文本计算"></a>文本计算</h4><p>如果一个界面中包含大量文本（比如微博微信朋友圈等），文本的宽高计算会占用很大一部分资源，并且不可避免。如果你对文本显示没有特殊要求，可以参考下 UILabel 内部的实现方式：用 [NSAttributedString boundingRectWithSize:options:context:] 来计算文本宽高，用 -[NSAttributedString drawWithRect:options:context:] 来绘制文本。尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程。</p>
<p>如果你用 CoreText 绘制文本，那就可以先生成 CoreText 排版对象，然后自己计算了，并且 CoreText 对象还能保留以供稍后绘制使用。</p>
<h4 id="文本渲染"><a href="#文本渲染" class="headerlink" title="文本渲染"></a>文本渲染</h4><p>屏幕上能看到的所有文本内容控件，包括 UIWebView，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的。常见的文本控件 （UILabel、UITextView 等），其排版和绘制都是在主线程进行的，当显示大量文本时，CPU 的压力会非常大。对此解决方案只有一个，那就是自定义文本控件，用 TextKit 或最底层的 CoreText 对文本异步绘制。尽管这实现起来非常麻烦，但其带来的优势也非常大，CoreText 对象创建好后，能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）；CoreText 对象占用内存较少，可以缓存下来以备稍后多次渲染。</p>
<h4 id="图片的解码"><a href="#图片的解码" class="headerlink" title="图片的解码"></a>图片的解码</h4><p>当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。</p>
<h4 id="图像的绘制"><a href="#图像的绘制" class="headerlink" title="图像的绘制"></a>图像的绘制</h4><p>图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。这个最常见的地方就是 [UIView drawRect:] 里面了。由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。一个简单异步绘制的过程大致如下（实际情况会比这个复杂得多，但原理基本一致）：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)display &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(backgroundQueue, ^&#123;</span><br><span class="line">        <span class="built_in">CGContextRef</span> ctx = <span class="built_in">CGBitmapContextCreate</span>(...);</span><br><span class="line">        <span class="comment">// draw in context...</span></span><br><span class="line">        <span class="built_in">CGImageRef</span> img = <span class="built_in">CGBitmapContextCreateImage</span>(ctx);</span><br><span class="line">        <span class="built_in">CFRelease</span>(ctx);</span><br><span class="line">        <span class="built_in">dispatch_async</span>(mainQueue, ^&#123;</span><br><span class="line">            layer.contents = img;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="GPU-资源消耗原因和解决方案"><a href="#GPU-资源消耗原因和解决方案" class="headerlink" title="GPU 资源消耗原因和解决方案"></a>GPU 资源消耗原因和解决方案</h3><p>相对于 CPU 来说，GPU 能干的事情比较单一：接收提交的纹理（Texture）和顶点描述（三角形），应用变换（transform）、混合并渲染，然后输出到屏幕上。通常你所能看到的内容，主要也就是纹理（图片）和形状（三角模拟的矢量图形）两类。</p>
<h4 id="纹理的渲染"><a href="#纹理的渲染" class="headerlink" title="纹理的渲染"></a>纹理的渲染</h4><p>所有的 Bitmap，包括图片、文本、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。当在较短时间显示大量图片时（比如 TableView 存在非常多的图片并且快速滑动时），CPU 占用率很低，GPU 占用非常高，界面仍然会掉帧。避免这种情况的方法只能是尽量减少在短时间内大量图片的显示，尽可能将多张图片合成为一张进行显示。</p>
<p>当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 和 GPU 都会带来额外的资源消耗。目前来说，iPhone 4S 以上机型，纹理尺寸上限都是 4096x4096，更详细的资料可以看这里：<a target="_blank" rel="noopener" href="http://iosres.com/">iosres.com</a>。所以，尽量不要让图片和视图的大小超过这个值。</p>
<h4 id="视图的混合-Composing"><a href="#视图的混合-Composing" class="headerlink" title="视图的混合 (Composing)"></a>视图的混合 (Composing)</h4><p>当多个视图（或者说 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多 GPU 资源。为了减轻这种情况的 GPU 消耗，应用应当尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。当然，这也可以用上面的方法，把多个视图预先渲染为一张图片来显示。</p>
<h4 id="图形的生成。"><a href="#图形的生成。" class="headerlink" title="图形的生成。"></a>图形的生成。</h4><p>CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染（offscreen rendering），而离屏渲染通常发生在 GPU 中。当一个列表视图中出现大量圆角的 CALayer，并且快速滑动时，可以观察到 GPU 资源已经占满，而 CPU 资源消耗很少。这时界面仍然能正常滑动，但平均帧数会降到很低。为了避免这种情况，可以尝试开启 CALayer.shouldRasterize 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去。对于只需要圆角的某些场合，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。最彻底的解决办法，就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。</p>
<h2 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h2><p>AsyncDisplayKit 是 Facebook 开源的一个用于保持 iOS 界面流畅的库，我从中学到了很多东西，所以下面我会花较大的篇幅来对其进行介绍和分析。</p>
<h4 id="ASDK-的由来"><a href="#ASDK-的由来" class="headerlink" title="ASDK 的由来"></a>ASDK 的由来</h4><p><a href="/img/keepScreenFluent/scott_goodson.png"><img src = "/img/keepScreenFluent/scott_goodson.png" width = 300 height = 300 alt = "scott_goodson" /></a></p>
<p>ASDK 的作者是 Scott Goodson (<a target="_blank" rel="noopener" href="https://www.linkedin.com/in/iosengineer">Linkedin</a>)，<br>他曾经在苹果工作，负责 iOS 的一些内置应用的开发，比如股票、计算器、地图、钟表、设置、Safari 等，当然他也参与了 UIKit framework 的开发。后来他加入 Facebook 后，负责 Paper 的开发，创建并开源了 AsyncDisplayKit。目前他在 Pinterest 和 Instagram 负责 iOS 开发和用户体验的提升等工作。</p>
<p><a href="/img/keepScreenFluent/asdk_history.png"><img src = "/img/keepScreenFluent/asdk_history.png" width = 484 height = 160 alt = "asdk_history" /></a></p>
<p>ASDK 自 2014 年 6 月开源，10 月发布 1.0 版。目前 ASDK 即将要发布 2.0 版。<br>V2.0 增加了更多布局相关的代码，ComponentKit 团队为此贡献很多。<br>现在 Github 的 master 分支上的版本是 V1.9.1，已经包含了 V2.0 的全部内容。</p>
<h4 id="ASDK-的资料"><a href="#ASDK-的资料" class="headerlink" title="ASDK 的资料"></a>ASDK 的资料</h4><p>想要了解 ASDK 的原理和细节，最好从下面几个视频开始：<br>2014.10.15 <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=-IPMNWqA638">NSLondon - Scott Goodson - Behind AsyncDisplayKit</a><br>2015.03.02 <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=ZPL4Nse76oY">MCE 2015 - Scott Goodson - Effortless Responsiveness with AsyncDisplayKit</a><br>2015.10.25 <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=RY_X7l1g79Q">AsyncDisplayKit 2.0: Intelligent User Interfaces - NSSpain 2015</a><br>前两个视频内容大同小异，都是介绍 ASDK 的基本原理，附带介绍 POP 等其他项目。<br>后一个视频增加了 ASDK 2.0 的新特性的介绍。</p>
<p>除此之外，还可以到 Github Issues 里看一下 ASDK 相关的讨论，下面是几个比较重要的内容：<br><a target="_blank" rel="noopener" href="https://github.com/facebook/AsyncDisplayKit/issues/42">关于 Runloop Dispatch</a><br><a target="_blank" rel="noopener" href="https://github.com/facebook/AsyncDisplayKit/issues/70">关于 ComponentKit 和 ASDK 的区别</a><br><a target="_blank" rel="noopener" href="https://github.com/facebook/AsyncDisplayKit/issues/132">为什么不支持 Storyboard 和 Autolayout</a><br><a target="_blank" rel="noopener" href="https://github.com/facebook/AsyncDisplayKit/issues/204">如何评测界面的流畅度</a></p>
<p>之后，还可以到 Google Groups 来查看和讨论更多内容：<br><a target="_blank" rel="noopener" href="https://groups.google.com/forum/#!forum/asyncdisplaykit">https://groups.google.com/forum/#!forum&#x2F;asyncdisplaykit</a></p>
<h4 id="ASDK-的基本原理"><a href="#ASDK-的基本原理" class="headerlink" title="ASDK 的基本原理"></a>ASDK 的基本原理</h4><p><a href="/img/keepScreenFluent/asdk_design.png"><img src = "/img/keepScreenFluent/asdk_design.png" width = 496 height = 255 alt = "asdk_design" /></a></p>
<p>ASDK 认为，阻塞主线程的任务，主要分为上面这三大类。文本和布局的计算、渲染、解码、绘制都可以通过各种方式异步执行，但 UIKit 和 Core Animation 相关操作必需在主线程进行。ASDK 的目标，就是尽量把这些任务从主线程挪走，而挪不走的，就尽量优化性能。</p>
<p>为了达成这一目标，ASDK 尝试对 UIKit 组件进行封装：</p>
<p><a href="/img/keepScreenFluent/asdk_layer_backed_view.png"><img src = "/img/keepScreenFluent/asdk_layer_backed_view.png" width = 363 height = 162 alt = "asdk_layer_backed_view" /></a></p>
<p>这是常见的 UIView 和 CALayer 的关系：View 持有 Layer 用于显示，View 中大部分显示属性实际是从 Layer 映射而来；Layer 的 delegate 在这里是 View，当其属性改变、动画产生时，View 能够得到通知。UIView 和 CALayer 不是线程安全的，并且只能在主线程创建、访问和销毁。</p>
<p><a href="/img/keepScreenFluent/asdk_view_backed_node.png"><img src = "/img/keepScreenFluent/asdk_view_backed_node.png" width = 605 height = 167 alt = "asdk_view_backed_node" /></a></p>
<p>ASDK 为此创建了 ASDisplayNode 类，包装了常见的视图属性（比如 frame&#x2F;bounds&#x2F;alpha&#x2F;transform&#x2F;backgroundColor&#x2F;superNode&#x2F;subNodes 等），然后它用 UIView-&gt;CALayer 相同的方式，实现了 ASNode-&gt;UIView 这样一个关系。</p>
<p><a href="/img/keepScreenFluent/asdk_layer_backed_node.png"><img src = "/img/keepScreenFluent/asdk_layer_backed_node.png" width = 605 height = 167 alt = "asdk_layer_backed_node" /></a></p>
<p>当不需要响应触摸事件时，ASDisplayNode 可以被设置为 layer backed，即 ASDisplayNode 充当了原来 UIView 的功能，节省了更多资源。</p>
<p>与 UIView 和 CALayer 不同，ASDisplayNode 是线程安全的，它可以在后台线程创建和修改。Node 刚创建时，并不会在内部新建 UIView 和 CALayer，直到第一次在主线程访问 view 或 layer 属性时，它才会在内部生成对应的对象。当它的属性（比如frame&#x2F;transform）改变后，它并不会立刻同步到其持有的 view 或 layer 去，而是把被改变的属性保存到内部的一个中间变量，稍后在需要时，再通过某个机制一次性设置到内部的 view 或 layer。</p>
<p>通过模拟和封装 UIView&#x2F;CALayer，开发者可以把代码中的 UIView 替换为 ASNode，很大的降低了开发和学习成本，同时能获得 ASDK 底层大量的性能优化。为了方便使用， ASDK 把大量常用控件都封装成了 ASNode 的子类，比如 Button、Control、Cell、Image、ImageView、Text、TableView、CollectionView 等。利用这些控件，开发者可以尽量避免直接使用 UIKit 相关控件，以获得更完整的性能提升。</p>
<h4 id="ASDK-的图层预合成"><a href="#ASDK-的图层预合成" class="headerlink" title="ASDK 的图层预合成"></a>ASDK 的图层预合成</h4><p><a href="/img/keepScreenFluent/asdk_comoose_1.png"><img src = "/img/keepScreenFluent/asdk_comoose_1.png" width = 195 height = 195 alt = "asdk_comoose_1" /></a> <a href="/img/keepScreenFluent/asdk_compose_2.png"><img src = "/img/keepScreenFluent/asdk_compose_2.png" width = 195 height = 195 alt = "asdk_compose_2" /></a></p>
<p>有时一个 layer 会包含很多 sub-layer，而这些 sub-layer 并不需要响应触摸事件，也不需要进行动画和位置调整。ASDK 为此实现了一个被称为 pre-composing 的技术，可以把这些 sub-layer 合成渲染为一张图片。开发时，ASNode 已经替代了 UIView 和 CALayer；直接使用各种 Node 控件并设置为 layer backed 后，ASNode 甚至可以通过预合成来避免创建内部的 UIView 和 CALayer。</p>
<p>通过这种方式，把一个大的层级，通过一个大的绘制方法绘制到一张图上，性能会获得很大提升。CPU 避免了创建 UIKit 对象的资源消耗，GPU 避免了多张 texture 合成和渲染的消耗，更少的 bitmap 也意味着更少的内存占用。</p>
<h4 id="ASDK-异步并发操作"><a href="#ASDK-异步并发操作" class="headerlink" title="ASDK 异步并发操作"></a>ASDK 异步并发操作</h4><p><a href="/img/keepScreenFluent/asdk_a9_chip.jpg"><img src = "/img/keepScreenFluent/asdk_a9_chip.jpg" width = 314 height = 177 alt = "asdk_a9_chip" /></a></p>
<p>自 iPhone 4S 起，iDevice 已经都是双核 CPU 了，现在的 iPad 甚至已经更新到 3 核了。充分利用多核的优势、并发执行任务对保持界面流畅有很大作用。ASDK 把布局计算、文本排版、图片&#x2F;文本&#x2F;图形渲染等操作都封装成较小的任务，并利用 GCD 异步并发执行。如果开发者使用了 ASNode 相关的控件，那么这些并发操作会自动在后台进行，无需进行过多配置。</p>
<h4 id="Runloop-任务分发"><a href="#Runloop-任务分发" class="headerlink" title="Runloop 任务分发"></a>Runloop 任务分发</h4><p>Runloop work distribution 是 ASDK 比较核心的一个技术，ASDK 的介绍视频和文档中都没有详细展开介绍，所以这里我会多做一些分析。如果你对 Runloop 还不太了解，可以看一下我之前的文章 <a target="_blank" rel="noopener" href="http://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a>，里面对 ASDK 也有所提及。</p>
<p><a href="/img/keepScreenFluent/ios_vsync_runloop.png"><img src = "/img/keepScreenFluent/ios_vsync_runloop.png" width = 564 height = 234 alt = "ios_vsync_runloop" /></a></p>
<p>iOS 的显示系统是由 VSync 信号驱动的，VSync 信号由硬件时钟生成，每秒钟发出 60 次（这个值取决设备硬件，比如 iPhone 真机上通常是 59.97）。iOS 图形服务接收到 VSync 信号后，会通过 IPC 通知到 App 内。App 的 Runloop 在启动后会注册对应的 CFRunLoopSource 通过 mach_port 接收传过来的时钟信号通知，随后 Source 的回调会驱动整个 App 的动画与显示。</p>
<p>Core Animation 在 RunLoop 中注册了一个 Observer，监听了 BeforeWaiting 和 Exit 事件。这个 Observer 的优先级是 2000000，低于常见的其他 Observer。当一个触摸事件到来时，RunLoop 被唤醒，App 中的代码会执行一些操作，比如创建和调整视图层级、设置 UIView 的 frame、修改 CALayer 的透明度、为视图添加一个动画；这些操作最终都会被 CALayer 捕获，并通过 CATransaction 提交到一个中间状态去（CATransaction 的文档略有提到这些内容，但并不完整）。当上面所有操作结束后，RunLoop 即将进入休眠（或者退出）时，关注该事件的 Observer 都会得到通知。这时 CA 注册的那个 Observer 就会在回调中，把所有的中间状态合并提交到 GPU 去显示；如果此处有动画，CA 会通过 DisplayLink 等机制多次触发相关流程。</p>
<p>ASDK 在此处模拟了 Core Animation 的这个机制：所有针对 ASNode 的修改和提交，总有些任务是必需放入主线程执行的。当出现这种任务时，ASNode 会把任务用 ASAsyncTransaction(Group) 封装并提交到一个全局的容器去。ASDK 也在 RunLoop 中注册了一个 Observer，监视的事件和 CA 一样，但优先级比 CA 要低。当 RunLoop 进入休眠前、CA 处理完事件后，ASDK 就会执行该 loop 内提交的所有任务。具体代码见这个文件：<a target="_blank" rel="noopener" href="https://github.com/facebook/AsyncDisplayKit/blob/master/AsyncDisplayKit%2FDetails%2FTransactions%2F_ASAsyncTransactionGroup.m">ASAsyncTransactionGroup</a>。</p>
<p>通过这种机制，ASDK 可以在合适的机会把异步、并发的操作同步到主线程去，并且能获得不错的性能。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>ASDK 中还有封装很多高级的功能，比如滑动列表的预加载、V2.0添加的新的布局模式等。ASDK 是一个很庞大的库，它本身并不推荐你把整个 App 全部都改为 ASDK 驱动，把最需要提升交互性能的地方用 ASDK 进行优化就足够了。</p>
<h2 id="微博-Demo-性能优化技巧"><a href="#微博-Demo-性能优化技巧" class="headerlink" title="微博 Demo 性能优化技巧"></a>微博 Demo 性能优化技巧</h2><p>我为了演示 YYKit 的功能，实现了微博和 Twitter 的 Demo，并为它们做了不少性能优化，下面就是优化时用到的一些技巧。</p>
<h4 id="预排版"><a href="#预排版" class="headerlink" title="预排版"></a>预排版</h4><p>当获取到 API JSON 数据后，我会把每条 Cell 需要的数据都在后台线程计算并封装为一个布局对象 CellLayout。CellLayout 包含所有文本的 CoreText 排版结果、Cell 内部每个控件的高度、Cell 的整体高度。每个 CellLayout 的内存占用并不多，所以当生成后，可以全部缓存到内存，以供稍后使用。这样，TableView 在请求各个高度函数时，不会消耗任何多余计算量；当把 CellLayout 设置到 Cell 内部时，Cell 内部也不用再计算布局了。</p>
<p>对于通常的 TableView 来说，提前在后台计算好布局结果是非常重要的一个性能优化点。为了达到最高性能，你可能需要牺牲一些开发速度，不要用 Autolayout 等技术，少用 UILabel 等文本控件。但如果你对性能的要求并不那么高，可以尝试用 TableView 的预估高度的功能，并把每个 Cell 高度缓存下来。这里有个来自百度知道团队的开源项目可以很方便的帮你实现这一点：<a target="_blank" rel="noopener" href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell/">FDTemplateLayoutCell</a>。</p>
<h4 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h4><p>微博的头像在某次改版中换成了圆形，所以我也跟进了一下。当头像下载下来后，我会在后台线程将头像预先渲染为圆形并单独保存到一个 ImageCache 中去。</p>
<p>对于 TableView 来说，Cell 内容的离屏渲染会带来较大的 GPU 消耗。在 Twitter Demo 中，我为了图省事儿用到了不少 layer 的圆角属性，你可以在低性能的设备（比如 iPad 3）上快速滑动一下这个列表，能感受到虽然列表并没有较大的卡顿，但是整体的平均帧数降了下来。用 Instument 查看时能够看到 GPU 已经满负荷运转，而 CPU 却比较清闲。为了避免离屏渲染，你应当尽量避免使用 layer 的 border、corner、shadow、mask 等技术，而尽量在后台线程预先绘制好对应内容。</p>
<h4 id="异步绘制"><a href="#异步绘制" class="headerlink" title="异步绘制"></a>异步绘制</h4><p>我只在显示文本的控件上用到了异步绘制的功能，但效果很不错。我参考 ASDK 的原理，实现了一个简单的异步绘制控件。这块代码我单独提取出来，放到了这里：<a target="_blank" rel="noopener" href="https://github.com/ibireme/YYAsyncLayer">YYAsyncLayer</a>。YYAsyncLayer 是 CALayer 的子类，当它需要显示内容（比如调用了 [layer setNeedDisplay]）时，它会向 delegate，也就是 UIView 请求一个异步绘制的任务。在异步绘制时，Layer 会传递一个 <font color='#008000'>BOOL(^isCancelled)()</font> 这样的 block，绘制代码可以随时调用该 block 判断绘制任务是否已经被取消。</p>
<p>当 TableView 快速滑动时，会有大量异步绘制任务提交到后台线程去执行。但是有时滑动速度过快时，绘制任务还没有完成就可能已经被取消了。如果这时仍然继续绘制，就会造成大量的 CPU 资源浪费，甚至阻塞线程并造成后续的绘制任务迟迟无法完成。我的做法是尽量快速、提前判断当前绘制任务是否已经被取消；在绘制每一行文本前，我都会调用 isCancelled() 来进行判断，保证被取消的任务能及时退出，不至于影响后续操作。</p>
<p>目前有些第三方微博客户端（比如 VVebo、墨客等），使用了一种方式来避免高速滑动时 Cell 的绘制过程，相关实现见这个项目：<a target="_blank" rel="noopener" href="https://github.com/johnil/VVeboTableViewDemo">VVeboTableViewDemo</a>。它的原理是，当滑动时，松开手指后，立刻计算出滑动停止时 Cell 的位置，并预先绘制那个位置附近的几个 Cell，而忽略当前滑动中的 Cell。这个方法比较有技巧性，并且对于滑动性能来说提升也很大，唯一的缺点就是快速滑动中会出现大量空白内容。如果你不想实现比较麻烦的异步绘制但又想保证滑动的流畅性，这个技巧是个不错的选择。</p>
<h4 id="全局并发控制"><a href="#全局并发控制" class="headerlink" title="全局并发控制"></a>全局并发控制</h4><p>当我用 concurrent queue 来执行大量绘制任务时，偶尔会遇到这种问题：</p>
<p><a href="/img/keepScreenFluent/ios_dispatch_blocked_1.png"><img src = "/img/keepScreenFluent/ios_dispatch_blocked_1.png" width = 189 height = 350 alt = "ios_dispatch_blocked_1" /></a><a href="/img/keepScreenFluent/ios_dispatch_blocked_2.png"><img src = "/img/keepScreenFluent/ios_dispatch_blocked_2.png" width = 189 height = 250 alt = "ios_dispatch_blocked_2" /></a></p>
<p>大量的任务提交到后台队列时，某些任务会因为某些原因（此处是 CGFont 锁）被锁住导致线程休眠，或者被阻塞，concurrent queue 随后会创建新的线程来执行其他任务。当这种情况变多时，或者 App 中使用了大量 concurrent queue 来执行较多任务时，App 在同一时刻就会存在几十个线程同时运行、创建、销毁。CPU 是用时间片轮转来实现线程并发的，尽管 concurrent queue 能控制线程的优先级，但当大量线程同时创建运行销毁时，这些操作仍然会挤占掉主线程的 CPU 资源。ASDK 有个 Feed 列表的 Demo：<a target="_blank" rel="noopener" href="https://github.com/facebook/AsyncDisplayKit/tree/master/examples/SocialAppLayout">SocialAppLayout</a>，当列表内 Cell 过多，并且非常快速的滑动时，界面仍然会出现少量卡顿，我谨慎的猜测可能与这个问题有关。</p>
<p>使用 concurrent queue 时不可避免会遇到这种问题，但使用 serial queue 又不能充分利用多核 CPU 的资源。我写了一个简单的工具 <a target="_blank" rel="noopener" href="https://github.com/ibireme/YYDispatchQueuePool">YYDispatchQueuePool</a>，为不同优先级创建和 CPU 数量相同的 serial queue，每次从 pool 中获取 queue 时，会轮询返回其中一个 queue。我把 App 内所有异步操作，包括图像解码、对象释放、异步绘制等，都按优先级不同放入了全局的 serial queue 中执行，这样尽量避免了过多线程导致的性能问题。</p>
<h4 id="更高效的异步图片加载"><a href="#更高效的异步图片加载" class="headerlink" title="更高效的异步图片加载"></a>更高效的异步图片加载</h4><p>SDWebImage 在这个 Demo 里仍然会产生少量性能问题，并且有些地方不能满足我的需求，所以我自己实现了一个性能更高的图片加载库。在显示简单的单张图片时，利用 UIView.layer.contents 就足够了，没必要使用 UIImageView 带来额外的资源消耗，为此我在 CALayer 上添加了 setImageWithURL 等方法。除此之外，我还把图片解码等操作通过 YYDispatchQueuePool 进行管理，控制了 App 总线程数量。</p>
<h4 id="其他可以改进的地方"><a href="#其他可以改进的地方" class="headerlink" title="其他可以改进的地方"></a>其他可以改进的地方</h4><p>上面这些优化做完后，微博 Demo 已经非常流畅了，但在我的设想中，仍然有一些进一步优化的技巧，但限于时间和精力我并没有实现，下面简单列一下：</p>
<p>列表中有不少视觉元素并不需要触摸事件，这些元素可以用 ASDK 的图层合成技术预先绘制为一张图。</p>
<p>再进一步减少每个 Cell 内图层的数量，用 CALayer 替换掉 UIView。</p>
<p>目前每个 Cell 的类型都是相同的，但显示的内容却各部一样，比如有的 Cell 有图片，有的 Cell 里是卡片。把 Cell 按类型划分，进一步减少 Cell 内不必要的视图对象和操作，应该能有一些效果。</p>
<p>把需要放到主线程执行的任务划分为足够小的块，并通过 Runloop 来进行调度，在每个 Loop 里判断下一次 VSync 的时间，并在下次 VSync 到来前，把当前未执行完的任务延迟到下一个机会去。这个只是我的一个设想，并不一定能实现或起作用。</p>
<h2 id="如何评测界面的流畅度"><a href="#如何评测界面的流畅度" class="headerlink" title="如何评测界面的流畅度"></a>如何评测界面的流畅度</h2><p>最后还是要提一下，“过早的优化是万恶之源”，在需求未定，性能问题不明显时，没必要尝试做优化，而要尽量正确的实现功能。做性能优化时，也最好是走修改代码 -&gt; Profile -&gt; 修改代码这样一个流程，优先解决最值得优化的地方。</p>
<p>如果你需要一个明确的 FPS 指示器，可以尝试一下 <a target="_blank" rel="noopener" href="https://github.com/kconner/KMCGeigerCounter">KMCGeigerCounter</a>。对于 CPU 的卡顿，它可以通过内置的 CADisplayLink 检测出来；对于 GPU 带来的卡顿，它用了一个 1x1 的 SKView 来进行监视。这个项目有两个小问题：SKView 虽然能监视到 GPU 的卡顿，但引入 SKView 本身就会对 CPU&#x2F;GPU 带来额外的一点的资源消耗；这个项目在 iOS 9 下有一些兼容问题，需要稍作调整。</p>
<p>我自己也写了个简单的 FPS 指示器：<a target="_blank" rel="noopener" href="https://github.com/ibireme/YYText/blob/master/Demo/YYTextDemo/YYFPSLabel.m">FPSLabel</a> 只有几十行代码，仅用到了 CADisplayLink 来监视 CPU 的卡顿问题。虽然不如上面这个工具完善，但日常使用没有太大问题。</p>
<p>最后，用 Instuments 的 GPU Driver 预设，能够实时查看到 CPU 和 GPU 的资源消耗。在这个预设内，你能查看到几乎所有与显示有关的数据，比如 Texture 数量、CA 提交的频率、GPU 消耗等，在定位界面卡顿的问题时，这是最好的工具。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/07/11/iOSCodeSomeTip/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qxy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一艘小船">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/07/11/iOSCodeSomeTip/" class="post-title-link" itemprop="url">iOS开发中的一些小Tip</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-07-11 17:34:00" itemprop="dateCreated datePublished" datetime="2016-07-11T17:34:00+08:00">2016-07-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="iOS开发中如何检测当前运行商类型-移动、联通、电信"><a href="#iOS开发中如何检测当前运行商类型-移动、联通、电信" class="headerlink" title="iOS开发中如何检测当前运行商类型(移动、联通、电信) "></a><font color = #a2c700>iOS开发中如何检测当前运行商类型(移动、联通、电信) </font></h3><p>OS开发中，有时需要检测设备运营商类型，如移动、联通或者电信，本文以检测联通为例。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)checkIsUnicom</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CTTelephonyNetworkInfo</span> *info = [[<span class="built_in">CTTelephonyNetworkInfo</span> alloc] init];</span><br><span class="line">    <span class="built_in">CTCarrier</span> *carrier = info.subscriberCellularProvider;</span><br><span class="line">    <span class="built_in">NSString</span> *carrierName = carrier.carrierName;</span><br><span class="line">    <span class="built_in">NSString</span> *mobileCountryCode = carrier.mobileCountryCode;</span><br><span class="line">    <span class="built_in">NSString</span> *mobileNetworkCode = carrier.mobileNetworkCode;</span><br><span class="line">    [info release];</span><br><span class="line">    <span class="keyword">if</span> (!mobileNetworkCode) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([mobileCountryCode intValue]==<span class="number">460</span>) &#123; <span class="comment">//国内</span></span><br><span class="line">        <span class="keyword">return</span> [carrierName rangeOfString:<span class="string">@&quot;联通&quot;</span>].length&gt;<span class="number">0</span> ||</span><br><span class="line">         [mobileNetworkCode isEqualToString:<span class="string">@&quot;01&quot;</span>]   ||</span><br><span class="line">         [mobileNetworkCode isEqualToString:<span class="string">@&quot;06&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> statusBarCheckIsUnicom];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行商对应的NetworkCode</p>
<p><img src="/img/iOSCodeSomeTip/iOSSomeTip_1.png"></p>
<p>正常情况下，以上代码可满足正常需求，但是对于美版或者日版卡贴iPhone，检测到的CTCarrier并非sim卡信息，此时就需要通过StatusBar实时检测当前网络运行商</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)statusBarCheckIsUnicom</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *subviews = [[[[<span class="built_in">UIApplication</span> sharedApplication] valueForKey:<span class="string">@&quot;statusBar&quot;</span>]</span><br><span class="line">     valueForKey:<span class="string">@&quot;foregroundView&quot;</span>] subviews];</span><br><span class="line">    <span class="built_in">UIView</span> *serviceView = <span class="literal">nil</span>;</span><br><span class="line">    Class serviceClass = <span class="built_in">NSClassFromString</span>([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;UIStat%@Serv%@%@&quot;</span>, </span><br><span class="line">    <span class="string">@&quot;usBar&quot;</span>, <span class="string">@&quot;ice&quot;</span>, <span class="string">@&quot;ItemView&quot;</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> *subview <span class="keyword">in</span> subviews) &#123;</span><br><span class="line">        <span class="keyword">if</span>([subview isKindOfClass:[serviceClass <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            serviceView = subview;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (serviceView) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *carrierName = [serviceView valueForKey:[<span class="string">@&quot;service&quot;</span> </span><br><span class="line">        stringByAppendingString:<span class="string">@&quot;String&quot;</span>]];</span><br><span class="line">        <span class="keyword">return</span> [carrierName rangeOfString:<span class="string">@&quot;联通&quot;</span>].length&gt;<span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="iOS9-进行第三方跳转"><a href="#iOS9-进行第三方跳转" class="headerlink" title=" iOS9 进行第三方跳转 "></a><font color = #a2c700> iOS9 进行第三方跳转 </font></h3><p>需要在plist 加入：</p>
<pre><code>&lt;key&gt;LSApplicationQueriesSchemes&lt;/key&gt;
    &lt;array&gt;
    &lt;string&gt;wechat&lt;/string&gt;
    &lt;string&gt;local&lt;/string&gt;
    &lt;string&gt;weixin&lt;/string&gt;
    &lt;string&gt;sinaweibohd&lt;/string&gt;
    &lt;string&gt;sinaweibo&lt;/string&gt;
    &lt;string&gt;sinaweibosso&lt;/string&gt;
    &lt;string&gt;weibosdk&lt;/string&gt;
    &lt;string&gt;alisdkdemo&lt;/string&gt;
    &lt;string&gt;weibosdk2.5&lt;/string&gt;
    &lt;string&gt;mqqapi&lt;/string&gt;
    &lt;string&gt;mqqbrowser&lt;/string&gt;
    &lt;string&gt;mqq&lt;/string&gt;
    &lt;string&gt;mqqOpensdkSSoLogin&lt;/string&gt;
    &lt;string&gt;mqqconnect&lt;/string&gt;
    &lt;string&gt;mqqopensdkdataline&lt;/string&gt;
    &lt;string&gt;mqqopensdkgrouptribeshare&lt;/string&gt;
    &lt;string&gt;mqqopensdkfriend&lt;/string&gt;
    &lt;string&gt;mqqopensdkapi&lt;/string&gt;
    &lt;string&gt;mqqopensdkapiV2&lt;/string&gt;
    &lt;string&gt;mqqopensdkapiV3&lt;/string&gt;
    &lt;string&gt;mqzoneopensdk&lt;/string&gt;
    &lt;string&gt;wtloginmqq&lt;/string&gt;
    &lt;string&gt;wtloginmqq2&lt;/string&gt;
    &lt;string&gt;mqqwpa&lt;/string&gt;
    &lt;string&gt;safepay&lt;/string&gt;
    &lt;string&gt;mqzone&lt;/string&gt;
    &lt;string&gt;mqqapiwallet&lt;/string&gt;
    &lt;string&gt;mqzonev2&lt;/string&gt;
    &lt;string&gt;mqzoneshare&lt;/string&gt;
    &lt;string&gt;wtloginqzone&lt;/string&gt;
    &lt;string&gt;mqzonewx&lt;/string&gt;
    &lt;string&gt;mqzoneopensdkapiV2&lt;/string&gt;
    &lt;string&gt;mqzoneopensdkapi19&lt;/string&gt;
    &lt;string&gt;mqzoneopensdkapi&lt;/string&gt;
    &lt;string&gt;mqzoneopensdk&lt;/string&gt;
    &lt;string&gt;renrenios&lt;/string&gt;
    &lt;string&gt;renrenapi&lt;/string&gt;
    &lt;string&gt;renren&lt;/string&gt;
    &lt;string&gt;renreniphone&lt;/string&gt;
    &lt;string&gt;yixin&lt;/string&gt;
    &lt;string&gt;instagram&lt;/string&gt;
    &lt;string&gt;whatsapp&lt;/string&gt;
    &lt;string&gt;line&lt;/string&gt;
    &lt;string&gt;fbapi&lt;/string&gt;
    &lt;string&gt;fb-messenger-api&lt;/string&gt;
    &lt;string&gt;fbauth2&lt;/string&gt;
    &lt;string&gt;fbshareextension&lt;/string&gt;
    &lt;string&gt;alipay&lt;/string&gt;
    &lt;string&gt;cydia&lt;/string&gt;
    &lt;string&gt;safepay&lt;/string&gt;
    &lt;/array&gt;
</code></pre>
<h3 id="判断设备的型号"><a href="#判断设备的型号" class="headerlink" title=" 判断设备的型号 "></a><font color = #a2c700> 判断设备的型号 </font></h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;sys/utsname.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获得设备型号</span></span><br><span class="line">+ (<span class="built_in">NSString</span> *)getCurrentDeviceModel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> utsname systemInfo;</span><br><span class="line">    uname(&amp;systemInfo);</span><br><span class="line">    <span class="built_in">NSString</span> *platform = [<span class="built_in">NSString</span> stringWithCString:systemInfo.machine</span><br><span class="line">                                              encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPhone1,1&quot;</span>]) <span class="keyword">return</span> <span class="string">@&quot;iPhone 2G (A1203)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPhone1,2&quot;</span>]) <span class="keyword">return</span> <span class="string">@&quot;iPhone 3G (A1241/A1324)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPhone2,1&quot;</span>]) <span class="keyword">return</span> <span class="string">@&quot;iPhone 3GS (A1303/A1325)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPhone3,1&quot;</span>]) <span class="keyword">return</span> <span class="string">@&quot;iPhone 4 (A1332)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPhone3,2&quot;</span>]) <span class="keyword">return</span> <span class="string">@&quot;iPhone 4 (A1332)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPhone3,3&quot;</span>]) <span class="keyword">return</span> <span class="string">@&quot;iPhone 4 (A1349)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPhone4,1&quot;</span>]) <span class="keyword">return</span> <span class="string">@&quot;iPhone 4S (A1387/A1431)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPhone5,1&quot;</span>]) <span class="keyword">return</span> <span class="string">@&quot;iPhone 5 (A1428)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPhone5,2&quot;</span>]) <span class="keyword">return</span> <span class="string">@&quot;iPhone 5 (A1429/A1442)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPhone5,3&quot;</span>]) <span class="keyword">return</span> <span class="string">@&quot;iPhone 5c (A1456/A1532)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPhone5,4&quot;</span>]) <span class="keyword">return</span> <span class="string">@&quot;iPhone 5c (A1507/A1516/A1526/A1529)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPhone6,1&quot;</span>]) <span class="keyword">return</span> <span class="string">@&quot;iPhone 5s (A1453/A1533)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPhone6,2&quot;</span>]) <span class="keyword">return</span> <span class="string">@&quot;iPhone 5s (A1457/A1518/A1528/A1530)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPhone7,1&quot;</span>]) <span class="keyword">return</span> <span class="string">@&quot;iPhone 6 Plus (A1522/A1524)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPhone7,2&quot;</span>]) <span class="keyword">return</span> <span class="string">@&quot;iPhone 6 (A1549/A1586)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPhone8,1&quot;</span>]) <span class="keyword">return</span> <span class="string">@&quot;iPhone 6s (A1633/A1688/A1691/A1700)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPhone8,2&quot;</span>]) <span class="keyword">return</span> <span class="string">@&quot;iPhone 6s Plus (A1634/A1687/A1690/A1699)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPod1,1&quot;</span>])   <span class="keyword">return</span> <span class="string">@&quot;iPod Touch 1G (A1213)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPod2,1&quot;</span>])   <span class="keyword">return</span> <span class="string">@&quot;iPod Touch 2G (A1288)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPod3,1&quot;</span>])   <span class="keyword">return</span> <span class="string">@&quot;iPod Touch 3G (A1318)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPod4,1&quot;</span>])   <span class="keyword">return</span> <span class="string">@&quot;iPod Touch 4G (A1367)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPod5,1&quot;</span>])   <span class="keyword">return</span> <span class="string">@&quot;iPod Touch 5G (A1421/A1509)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPad1,1&quot;</span>])   <span class="keyword">return</span> <span class="string">@&quot;iPad 1G (A1219/A1337)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPad2,1&quot;</span>])   <span class="keyword">return</span> <span class="string">@&quot;iPad 2 (A1395)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPad2,2&quot;</span>])   <span class="keyword">return</span> <span class="string">@&quot;iPad 2 (A1396)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPad2,3&quot;</span>])   <span class="keyword">return</span> <span class="string">@&quot;iPad 2 (A1397)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPad2,4&quot;</span>])   <span class="keyword">return</span> <span class="string">@&quot;iPad 2 (A1395+New Chip)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPad2,5&quot;</span>])   <span class="keyword">return</span> <span class="string">@&quot;iPad Mini 1G (A1432)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPad2,6&quot;</span>])   <span class="keyword">return</span> <span class="string">@&quot;iPad Mini 1G (A1454)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPad2,7&quot;</span>])   <span class="keyword">return</span> <span class="string">@&quot;iPad Mini 1G (A1455)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPad3,1&quot;</span>])   <span class="keyword">return</span> <span class="string">@&quot;iPad 3 (A1416)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPad3,2&quot;</span>])   <span class="keyword">return</span> <span class="string">@&quot;iPad 3 (A1403)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPad3,3&quot;</span>])   <span class="keyword">return</span> <span class="string">@&quot;iPad 3 (A1430)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPad3,4&quot;</span>])   <span class="keyword">return</span> <span class="string">@&quot;iPad 4 (A1458)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPad3,5&quot;</span>])   <span class="keyword">return</span> <span class="string">@&quot;iPad 4 (A1459)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPad3,6&quot;</span>])   <span class="keyword">return</span> <span class="string">@&quot;iPad 4 (A1460)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPad4,1&quot;</span>])   <span class="keyword">return</span> <span class="string">@&quot;iPad Air (A1474)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPad4,2&quot;</span>])   <span class="keyword">return</span> <span class="string">@&quot;iPad Air (A1475)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPad4,3&quot;</span>])   <span class="keyword">return</span> <span class="string">@&quot;iPad Air (A1476)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPad4,4&quot;</span>])   <span class="keyword">return</span> <span class="string">@&quot;iPad Mini 2G (A1489)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPad4,5&quot;</span>])   <span class="keyword">return</span> <span class="string">@&quot;iPad Mini 2G (A1490)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;iPad4,6&quot;</span>])   <span class="keyword">return</span> <span class="string">@&quot;iPad Mini 2G (A1491)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;i386&quot;</span>])      <span class="keyword">return</span> <span class="string">@&quot;iPhone Simulator&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@&quot;x86_64&quot;</span>])    <span class="keyword">return</span> <span class="string">@&quot;iPhone Simulator&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> platform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="隐藏返回按钮的文字"><a href="#隐藏返回按钮的文字" class="headerlink" title=" 隐藏返回按钮的文字 "></a><font color = #a2c700> 隐藏返回按钮的文字 </font></h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">UIBarButtonItem</span> appearance] setBackButtonTitlePositionAdjustment:<span class="built_in">UIOffsetMake</span>(<span class="number">0</span>, <span class="number">-60</span>)</span><br><span class="line">                                                         forBarMetrics:<span class="built_in">UIBarMetricsDefault</span>];   ```</span><br><span class="line">                                                         </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">### &lt;font color = #a2c700&gt; 判断 pickerView 是否正在滑动 &lt;/font&gt;</span><br><span class="line"></span><br><span class="line">```objectivec</span><br><span class="line">- (<span class="type">BOOL</span>)isScrolling:(<span class="built_in">UIView</span> *)view</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([view isKindOfClass:<span class="built_in">UIScrollView</span>.class]) &#123;</span><br><span class="line">        <span class="built_in">UIScrollView</span> * scrollView = (<span class="built_in">UIScrollView</span> *)view;</span><br><span class="line">        <span class="keyword">if</span> (scrollView.dragging || scrollView.decelerating) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> * aView <span class="keyword">in</span> view.subviews) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> isScrolling:aView]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ios8系统-点击设置隐私定位功能直接崩溃的问题"><a href="#ios8系统-点击设置隐私定位功能直接崩溃的问题" class="headerlink" title=" ios8系统 点击设置隐私定位功能直接崩溃的问题 "></a><font color = #a2c700> ios8系统 点击设置隐私定位功能直接崩溃的问题 </font></h3><p><img src="/img/iOSCodeSomeTip/iOSSomeTip_2.png"></p>
<h3 id="改变webView上的图片大小"><a href="#改变webView上的图片大小" class="headerlink" title=" 改变webView上的图片大小 "></a><font color = #a2c700> 改变webView上的图片大小 </font></h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * js = [<span class="built_in">NSString</span> stringWithFormat: <span class="string">@&quot;var script = document.createElement(&#x27;script&#x27;);&quot;</span></span><br><span class="line">                     <span class="string">&quot;script.type = &#x27;text/javascript&#x27;;&quot;</span></span><br><span class="line">                     <span class="string">&quot;script.text = \&quot;function ResizeImages() &#123; &quot;</span></span><br><span class="line">                     <span class="string">&quot;var myimg,oldwidth;&quot;</span></span><br><span class="line">                     <span class="string">&quot;var maxwidth=%f;&quot;</span> <span class="comment">//缩放系数</span></span><br><span class="line">                     <span class="string">&quot;for(i=0;i &lt;document.images.length;i++)&#123;&quot;</span></span><br><span class="line">                     <span class="string">&quot;myimg = document.images[i];&quot;</span></span><br><span class="line">                     <span class="string">&quot;if(myimg.width &gt; maxwidth)&#123;&quot;</span></span><br><span class="line">                     <span class="string">&quot;oldwidth = myimg.width;&quot;</span></span><br><span class="line">                     <span class="string">&quot;myimg.width = maxwidth;&quot;</span></span><br><span class="line">                     <span class="string">&quot;myimg.style.width = maxwidth+&#x27;px&#x27;;&quot;</span></span><br><span class="line">                     <span class="string">&quot;myimg.height = myimg.height * (maxwidth/oldwidth);&quot;</span></span><br><span class="line">                      <span class="string">&quot;myimg.style.height = &#x27;auto&#x27;;&quot;</span></span><br><span class="line">                     <span class="string">&quot;&#125;&quot;</span></span><br><span class="line">                     <span class="string">&quot;&#125;&quot;</span></span><br><span class="line">                     <span class="string">&quot;&#125;\&quot;;&quot;</span></span><br><span class="line">                     <span class="string">&quot;document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(script);&quot;</span>,kScreenWidth<span class="number">-10</span>];</span><br><span class="line">    [webView stringByEvaluatingJavaScriptFromString:js];</span><br><span class="line">    [webView stringByEvaluatingJavaScriptFromString:<span class="string">@&quot;ResizeImages();&quot;</span>];</span><br><span class="line">```      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### &lt;font color = #a2c700&gt; C文件申明冲突 &lt;/font&gt;</span><br><span class="line"></span><br><span class="line">头件的中的<span class="meta">#<span class="keyword">ifndef</span>，这是一个很关键的东西。比如你有两个C文件，这两个C文件都<span class="keyword">include</span>了同一个头文件。而编译时，这两个C文件要一同编译成一个可运行文件，于是问题来了，大量的声明冲突。</span></span><br><span class="line"></span><br><span class="line">还是把头文件的内容都放在<span class="meta">#<span class="keyword">ifndef</span>和#<span class="keyword">endif</span>中吧。不管你的头文件会不会被多个文件引用，你都要加上这个。一般格式是这样的：</span></span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> <span class="string">&lt;标识&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> <span class="string">&lt;标识&gt;</span></span></span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>


<p>&lt;标识&gt;在理论上来说可以是自由命名的，但每个头文件的这个“标识”都应该是唯一的。标识的命名规则一般是头文件名全大写，前后加下划线，并把文件名中的“.”也变成下划线，如：stdio.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _STDIO_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _STDIO_H_</span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br></pre></td></tr></table></figure>

<h3 id="Navigation-在-pop-和push-的时候奔溃"><a href="#Navigation-在-pop-和push-的时候奔溃" class="headerlink" title=" Navigation 在 pop 和push 的时候奔溃 "></a><font color = #a2c700> Navigation 在 pop 和push 的时候奔溃 </font></h3><p>一般是因为 delegate的问题</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewWillDisappear:(<span class="type">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewWillDisappear:animated];</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isMovingFromParentViewController])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.navigationController.delegate == <span class="keyword">self</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">self</span>.navigationController.delegate = <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pop回来后取消选中的cell"><a href="#pop回来后取消选中的cell" class="headerlink" title="  pop回来后取消选中的cell "></a><font color = #a2c700>  pop回来后取消选中的cell </font></h3><p>在 <code>viewWillAppear</code> 方法中加入：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.tableView deselectRowAtIndexPath:[<span class="keyword">self</span>.tableView indexPathForSelectedRow] animated:<span class="literal">YES</span>];                                                                                                       </span><br></pre></td></tr></table></figure>


<h3 id="CollectionView的cell太少无法拖动出来下拉刷新"><a href="#CollectionView的cell太少无法拖动出来下拉刷新" class="headerlink" title=" CollectionView的cell太少无法拖动出来下拉刷新 "></a><font color = #a2c700> CollectionView的cell太少无法拖动出来下拉刷新 </font></h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.collectionView.alwaysBounceVertical = <span class="literal">YES</span>;</span><br></pre></td></tr></table></figure>

<h3 id="导入C文件发生冲突"><a href="#导入C文件发生冲突" class="headerlink" title=" 导入C文件发生冲突  "></a><font color = #a2c700> 导入C文件发生冲突  </font></h3><p>在.pch文件加入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __OBJC__</span></span><br><span class="line">... oc的import</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">qxy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">qxy</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
